<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARGOBOTS: User-level Thread (ULT)</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ARGOBOTS
   &#160;<span id="projectnumber">e10f21f77711b5ff33ab18d338867e8f871f4d7c</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">User-level Thread (ULT)</div>  </div>
</div><!--header-->
<div class="contents">

<p>This group is for User-level Thread (ULT).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga186008e05c04170eed9ac74808619717"><td class="memItemLeft" align="right" valign="top">typedef struct ABT_thread_opaque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a></td></tr>
<tr class="memdesc:ga186008e05c04170eed9ac74808619717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work unit handle type.  <a href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">More...</a><br /></td></tr>
<tr class="separator:ga186008e05c04170eed9ac74808619717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49abe49beb3075b18fa79cf943f49219"><td class="memItemLeft" align="right" valign="top">typedef struct ABT_thread_attr_opaque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a></td></tr>
<tr class="memdesc:ga49abe49beb3075b18fa79cf943f49219"><td class="mdescLeft">&#160;</td><td class="mdescRight">ULT attribute handle type.  <a href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">More...</a><br /></td></tr>
<tr class="separator:ga49abe49beb3075b18fa79cf943f49219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga926da07d3af816e1116e5702f5ce4990"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga926da07d3af816e1116e5702f5ce4990">ABT_thread_state</a></td></tr>
<tr class="memdesc:ga926da07d3af816e1116e5702f5ce4990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work unit state type.  <a href="../../d0/d6d/group__ULT.html#ga926da07d3af816e1116e5702f5ce4990">More...</a><br /></td></tr>
<tr class="separator:ga926da07d3af816e1116e5702f5ce4990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c85a933a71326b53b59b835344747b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../de/dab/group__UNIT.html#ga8f4ca28fbf35ddd6a922e65f49723bee">ABT_unit_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga52c85a933a71326b53b59b835344747b">ABT_thread_id</a></td></tr>
<tr class="memdesc:ga52c85a933a71326b53b59b835344747b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work unit ID type.  <a href="../../d0/d6d/group__ULT.html#ga52c85a933a71326b53b59b835344747b">More...</a><br /></td></tr>
<tr class="separator:ga52c85a933a71326b53b59b835344747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa8e839d537fd79d677108d42d4176089"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a> { <a class="el" href="../../d0/d6d/group__ULT.html#ggaa8e839d537fd79d677108d42d4176089a87eb81bc600c1ceedc3e7c32cc7ea53a">ABT_THREAD_STATE_READY</a>, 
<a class="el" href="../../d0/d6d/group__ULT.html#ggaa8e839d537fd79d677108d42d4176089ae0a7acd9ed47699f063ee2128f9f7ef6">ABT_THREAD_STATE_RUNNING</a>, 
<a class="el" href="../../d0/d6d/group__ULT.html#ggaa8e839d537fd79d677108d42d4176089a3638f9519e790388f3bbc7e35f30fece">ABT_THREAD_STATE_BLOCKED</a>, 
<a class="el" href="../../d0/d6d/group__ULT.html#ggaa8e839d537fd79d677108d42d4176089ade61dddc74434ee2705c536698d07149">ABT_THREAD_STATE_TERMINATED</a>
 }</td></tr>
<tr class="memdesc:gaa8e839d537fd79d677108d42d4176089"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of a work unit.  <a href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">More...</a><br /></td></tr>
<tr class="separator:gaa8e839d537fd79d677108d42d4176089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga73bd1f04ce57def336cb20cdec9b14bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga73bd1f04ce57def336cb20cdec9b14bd">ABT_thread_create</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void(*thread_func)(void *), void *arg, <a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a> attr, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *newthread)</td></tr>
<tr class="memdesc:ga73bd1f04ce57def336cb20cdec9b14bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new ULT.  <a href="../../d0/d6d/group__ULT.html#ga73bd1f04ce57def336cb20cdec9b14bd">More...</a><br /></td></tr>
<tr class="separator:ga73bd1f04ce57def336cb20cdec9b14bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503c1948f3f577d2b079308364bf5158"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga503c1948f3f577d2b079308364bf5158">ABT_thread_create_on_xstream</a> (<a class="el" href="../../d3/def/group__ES.html#gad79a2fa8571915e3cfcd1383fcebf6f3">ABT_xstream</a> xstream, void(*thread_func)(void *), void *arg, <a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a> attr, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *newthread)</td></tr>
<tr class="memdesc:ga503c1948f3f577d2b079308364bf5158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new ULT associated with an execution stream.  <a href="../../d0/d6d/group__ULT.html#ga503c1948f3f577d2b079308364bf5158">More...</a><br /></td></tr>
<tr class="separator:ga503c1948f3f577d2b079308364bf5158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364549e7e443807ef073c744428d8c15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga364549e7e443807ef073c744428d8c15">ABT_thread_create_many</a> (int num_threads, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *pool_list, void(**thread_func_list)(void *), void **arg_list, <a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a> attr, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *newthread_list)</td></tr>
<tr class="memdesc:ga364549e7e443807ef073c744428d8c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a set of new ULTs.  <a href="../../d0/d6d/group__ULT.html#ga364549e7e443807ef073c744428d8c15">More...</a><br /></td></tr>
<tr class="separator:ga364549e7e443807ef073c744428d8c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c80cb3fe88262dd64e42ec63191d4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaf3c80cb3fe88262dd64e42ec63191d4e">ABT_thread_revive</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void(*thread_func)(void *), void *arg, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *thread)</td></tr>
<tr class="memdesc:gaf3c80cb3fe88262dd64e42ec63191d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revive a terminated work unit.  <a href="../../d0/d6d/group__ULT.html#gaf3c80cb3fe88262dd64e42ec63191d4e">More...</a><br /></td></tr>
<tr class="separator:gaf3c80cb3fe88262dd64e42ec63191d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31f748bfd565f97aa8ebabb89e9b632"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632">ABT_thread_free</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *thread)</td></tr>
<tr class="memdesc:gaf31f748bfd565f97aa8ebabb89e9b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a work unit.  <a href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632">More...</a><br /></td></tr>
<tr class="separator:gaf31f748bfd565f97aa8ebabb89e9b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f99be6079db81a6c651231096788d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga51f99be6079db81a6c651231096788d3">ABT_thread_free_many</a> (int num_threads, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *thread_list)</td></tr>
<tr class="memdesc:ga51f99be6079db81a6c651231096788d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a set of work units.  <a href="../../d0/d6d/group__ULT.html#ga51f99be6079db81a6c651231096788d3">More...</a><br /></td></tr>
<tr class="separator:ga51f99be6079db81a6c651231096788d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5275b75a5184bca258e803370e44bea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaf5275b75a5184bca258e803370e44bea">ABT_thread_join</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread)</td></tr>
<tr class="memdesc:gaf5275b75a5184bca258e803370e44bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a work unit to terminate.  <a href="../../d0/d6d/group__ULT.html#gaf5275b75a5184bca258e803370e44bea">More...</a><br /></td></tr>
<tr class="separator:gaf5275b75a5184bca258e803370e44bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c23f76b44d29ec70a18759ba019b050"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga7c23f76b44d29ec70a18759ba019b050">ABT_thread_join_many</a> (int num_threads, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *thread_list)</td></tr>
<tr class="memdesc:ga7c23f76b44d29ec70a18759ba019b050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a set of work units to terminate.  <a href="../../d0/d6d/group__ULT.html#ga7c23f76b44d29ec70a18759ba019b050">More...</a><br /></td></tr>
<tr class="separator:ga7c23f76b44d29ec70a18759ba019b050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a23f817ff7a6e7dc0ec95b474fd7404"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga2a23f817ff7a6e7dc0ec95b474fd7404">ABT_thread_exit</a> (void)</td></tr>
<tr class="memdesc:ga2a23f817ff7a6e7dc0ec95b474fd7404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate a calling ULT.  <a href="../../d0/d6d/group__ULT.html#ga2a23f817ff7a6e7dc0ec95b474fd7404">More...</a><br /></td></tr>
<tr class="separator:ga2a23f817ff7a6e7dc0ec95b474fd7404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218d94229458c2200f188e5ed2705afe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga218d94229458c2200f188e5ed2705afe">ABT_thread_cancel</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread)</td></tr>
<tr class="memdesc:ga218d94229458c2200f188e5ed2705afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a termination request to a work unit.  <a href="../../d0/d6d/group__ULT.html#ga218d94229458c2200f188e5ed2705afe">More...</a><br /></td></tr>
<tr class="separator:ga218d94229458c2200f188e5ed2705afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994a8e23d9c6ace41779d8ce2585ae88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga994a8e23d9c6ace41779d8ce2585ae88">ABT_thread_self</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *thread)</td></tr>
<tr class="memdesc:ga994a8e23d9c6ace41779d8ce2585ae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the calling work unit.  <a href="../../d0/d6d/group__ULT.html#ga994a8e23d9c6ace41779d8ce2585ae88">More...</a><br /></td></tr>
<tr class="separator:ga994a8e23d9c6ace41779d8ce2585ae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425f9c7a9f82efc642a9feb3d1c569c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga425f9c7a9f82efc642a9feb3d1c569c6">ABT_thread_self_id</a> (<a class="el" href="../../de/dab/group__UNIT.html#ga8f4ca28fbf35ddd6a922e65f49723bee">ABT_unit_id</a> *id)</td></tr>
<tr class="memdesc:ga425f9c7a9f82efc642a9feb3d1c569c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of the calling work unit.  <a href="../../d0/d6d/group__ULT.html#ga425f9c7a9f82efc642a9feb3d1c569c6">More...</a><br /></td></tr>
<tr class="separator:ga425f9c7a9f82efc642a9feb3d1c569c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe017b55ac9641198e73cdb99cbce8e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gabe017b55ac9641198e73cdb99cbce8e9">ABT_thread_get_last_xstream</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d3/def/group__ES.html#gad79a2fa8571915e3cfcd1383fcebf6f3">ABT_xstream</a> *xstream)</td></tr>
<tr class="memdesc:gabe017b55ac9641198e73cdb99cbce8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an execution stream associated with a work unit.  <a href="../../d0/d6d/group__ULT.html#gabe017b55ac9641198e73cdb99cbce8e9">More...</a><br /></td></tr>
<tr class="separator:gabe017b55ac9641198e73cdb99cbce8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9d02c8bdd6a75538b7301c9db0a485"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga7c9d02c8bdd6a75538b7301c9db0a485">ABT_thread_get_state</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a> *state)</td></tr>
<tr class="memdesc:ga7c9d02c8bdd6a75538b7301c9db0a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a state of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga7c9d02c8bdd6a75538b7301c9db0a485">More...</a><br /></td></tr>
<tr class="separator:ga7c9d02c8bdd6a75538b7301c9db0a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0baa47137ae3c140ff3c125b8a21ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga1d0baa47137ae3c140ff3c125b8a21ed">ABT_thread_get_last_pool</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *pool)</td></tr>
<tr class="memdesc:ga1d0baa47137ae3c140ff3c125b8a21ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last pool of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga1d0baa47137ae3c140ff3c125b8a21ed">More...</a><br /></td></tr>
<tr class="separator:ga1d0baa47137ae3c140ff3c125b8a21ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd69e6f45c2c4578bd736c197c5d2e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga4bd69e6f45c2c4578bd736c197c5d2e6">ABT_thread_get_last_pool_id</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, int *id)</td></tr>
<tr class="memdesc:ga4bd69e6f45c2c4578bd736c197c5d2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last pool's ID of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga4bd69e6f45c2c4578bd736c197c5d2e6">More...</a><br /></td></tr>
<tr class="separator:ga4bd69e6f45c2c4578bd736c197c5d2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15349fa8b9aa7e6f673f48e74ae75fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga15349fa8b9aa7e6f673f48e74ae75fc8">ABT_thread_set_associated_pool</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool)</td></tr>
<tr class="memdesc:ga15349fa8b9aa7e6f673f48e74ae75fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an associated pool for the target work unit.  <a href="../../d0/d6d/group__ULT.html#ga15349fa8b9aa7e6f673f48e74ae75fc8">More...</a><br /></td></tr>
<tr class="separator:ga15349fa8b9aa7e6f673f48e74ae75fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa419c69e734d2017e8238d438a216a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga1fa419c69e734d2017e8238d438a216a">ABT_thread_yield_to</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread)</td></tr>
<tr class="memdesc:ga1fa419c69e734d2017e8238d438a216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the calling ULT to the specific ULT.  <a href="../../d0/d6d/group__ULT.html#ga1fa419c69e734d2017e8238d438a216a">More...</a><br /></td></tr>
<tr class="separator:ga1fa419c69e734d2017e8238d438a216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177c58ca9094dc7feeb93521e30ff2aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga177c58ca9094dc7feeb93521e30ff2aa">ABT_thread_yield</a> (void)</td></tr>
<tr class="memdesc:ga177c58ca9094dc7feeb93521e30ff2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the calling ULT to its parent ULT.  <a href="../../d0/d6d/group__ULT.html#ga177c58ca9094dc7feeb93521e30ff2aa">More...</a><br /></td></tr>
<tr class="separator:ga177c58ca9094dc7feeb93521e30ff2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef94b0efbf392fdc4bd5d04f67f22a5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaef94b0efbf392fdc4bd5d04f67f22a5e">ABT_thread_resume</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread)</td></tr>
<tr class="memdesc:gaef94b0efbf392fdc4bd5d04f67f22a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a ULT.  <a href="../../d0/d6d/group__ULT.html#gaef94b0efbf392fdc4bd5d04f67f22a5e">More...</a><br /></td></tr>
<tr class="separator:gaef94b0efbf392fdc4bd5d04f67f22a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5495103e2bf9968136c381634fc242"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gafa5495103e2bf9968136c381634fc242">ABT_thread_migrate_to_xstream</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d3/def/group__ES.html#gad79a2fa8571915e3cfcd1383fcebf6f3">ABT_xstream</a> xstream)</td></tr>
<tr class="memdesc:gafa5495103e2bf9968136c381634fc242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a migration of a work unit to a specific execution stream.  <a href="../../d0/d6d/group__ULT.html#gafa5495103e2bf9968136c381634fc242">More...</a><br /></td></tr>
<tr class="separator:gafa5495103e2bf9968136c381634fc242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccc5f3082e1608f555dc06e9a70d202"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga8ccc5f3082e1608f555dc06e9a70d202">ABT_thread_migrate_to_sched</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d0/d83/group__SCHED.html#gadf0a564b506bb4a288f49cbfd3116025">ABT_sched</a> sched)</td></tr>
<tr class="memdesc:ga8ccc5f3082e1608f555dc06e9a70d202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a migration of a work unit to a specific scheduler.  <a href="../../d0/d6d/group__ULT.html#ga8ccc5f3082e1608f555dc06e9a70d202">More...</a><br /></td></tr>
<tr class="separator:ga8ccc5f3082e1608f555dc06e9a70d202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0414ecaedd36796a643e055bebafab99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga0414ecaedd36796a643e055bebafab99">ABT_thread_migrate_to_pool</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool)</td></tr>
<tr class="memdesc:ga0414ecaedd36796a643e055bebafab99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a migration of a work unit to a specific pool.  <a href="../../d0/d6d/group__ULT.html#ga0414ecaedd36796a643e055bebafab99">More...</a><br /></td></tr>
<tr class="separator:ga0414ecaedd36796a643e055bebafab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2646bfbabf0df851f964ae38a92804a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaa2646bfbabf0df851f964ae38a92804a">ABT_thread_migrate</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread)</td></tr>
<tr class="memdesc:gaa2646bfbabf0df851f964ae38a92804a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a migration of a work unit to any available execution streams.  <a href="../../d0/d6d/group__ULT.html#gaa2646bfbabf0df851f964ae38a92804a">More...</a><br /></td></tr>
<tr class="separator:gaa2646bfbabf0df851f964ae38a92804a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6379e8104b5f37a3a0a552a6973d613"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gab6379e8104b5f37a3a0a552a6973d613">ABT_thread_set_callback</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, void(*cb_func)(<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, void *cb_arg), void *cb_arg)</td></tr>
<tr class="memdesc:gab6379e8104b5f37a3a0a552a6973d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback function in a work unit.  <a href="../../d0/d6d/group__ULT.html#gab6379e8104b5f37a3a0a552a6973d613">More...</a><br /></td></tr>
<tr class="separator:gab6379e8104b5f37a3a0a552a6973d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e29ca342b00b88a18303f1c4a09905b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga5e29ca342b00b88a18303f1c4a09905b">ABT_thread_set_migratable</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> migratable)</td></tr>
<tr class="memdesc:ga5e29ca342b00b88a18303f1c4a09905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the migratability in a work unit.  <a href="../../d0/d6d/group__ULT.html#ga5e29ca342b00b88a18303f1c4a09905b">More...</a><br /></td></tr>
<tr class="separator:ga5e29ca342b00b88a18303f1c4a09905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68dc0d52cae397a965818516b34e0e09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga68dc0d52cae397a965818516b34e0e09">ABT_thread_is_migratable</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *is_migratable)</td></tr>
<tr class="memdesc:ga68dc0d52cae397a965818516b34e0e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the migratability of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga68dc0d52cae397a965818516b34e0e09">More...</a><br /></td></tr>
<tr class="separator:ga68dc0d52cae397a965818516b34e0e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748ab622b69796462333725a2513db1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga748ab622b69796462333725a2513db1a">ABT_thread_is_primary</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *is_primary)</td></tr>
<tr class="memdesc:ga748ab622b69796462333725a2513db1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a work unit is the primary ULT.  <a href="../../d0/d6d/group__ULT.html#ga748ab622b69796462333725a2513db1a">More...</a><br /></td></tr>
<tr class="separator:ga748ab622b69796462333725a2513db1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf91b0c5c7252f6e57ef253583635e7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gacf91b0c5c7252f6e57ef253583635e7c">ABT_thread_is_unnamed</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *is_unnamed)</td></tr>
<tr class="memdesc:gacf91b0c5c7252f6e57ef253583635e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a work unit is unnamed.  <a href="../../d0/d6d/group__ULT.html#gacf91b0c5c7252f6e57ef253583635e7c">More...</a><br /></td></tr>
<tr class="separator:gacf91b0c5c7252f6e57ef253583635e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40988251b2cc313fc60e4058c3d9021d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga40988251b2cc313fc60e4058c3d9021d">ABT_thread_equal</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread1, <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread2, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *result)</td></tr>
<tr class="memdesc:ga40988251b2cc313fc60e4058c3d9021d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two work unit handles for equality.  <a href="../../d0/d6d/group__ULT.html#ga40988251b2cc313fc60e4058c3d9021d">More...</a><br /></td></tr>
<tr class="separator:ga40988251b2cc313fc60e4058c3d9021d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1515f2d99034a3969855ebfbe1e0808"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gae1515f2d99034a3969855ebfbe1e0808">ABT_thread_get_stacksize</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, size_t *stacksize)</td></tr>
<tr class="memdesc:gae1515f2d99034a3969855ebfbe1e0808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a stack size of a work unit.  <a href="../../d0/d6d/group__ULT.html#gae1515f2d99034a3969855ebfbe1e0808">More...</a><br /></td></tr>
<tr class="separator:gae1515f2d99034a3969855ebfbe1e0808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31b2d9339e8675680d9e776108c9681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaa31b2d9339e8675680d9e776108c9681">ABT_thread_get_id</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../de/dab/group__UNIT.html#ga8f4ca28fbf35ddd6a922e65f49723bee">ABT_unit_id</a> *thread_id)</td></tr>
<tr class="memdesc:gaa31b2d9339e8675680d9e776108c9681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of a work unit.  <a href="../../d0/d6d/group__ULT.html#gaa31b2d9339e8675680d9e776108c9681">More...</a><br /></td></tr>
<tr class="separator:gaa31b2d9339e8675680d9e776108c9681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5048aacb8a6d3c91ddaf6c933d008415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga5048aacb8a6d3c91ddaf6c933d008415">ABT_thread_set_arg</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, void *arg)</td></tr>
<tr class="memdesc:ga5048aacb8a6d3c91ddaf6c933d008415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an argument for a work unit function of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga5048aacb8a6d3c91ddaf6c933d008415">More...</a><br /></td></tr>
<tr class="separator:ga5048aacb8a6d3c91ddaf6c933d008415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e903850717ed699af35989360bedd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga03e903850717ed699af35989360bedd8">ABT_thread_get_arg</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, void **arg)</td></tr>
<tr class="memdesc:ga03e903850717ed699af35989360bedd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an argument for a work unit function of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga03e903850717ed699af35989360bedd8">More...</a><br /></td></tr>
<tr class="separator:ga03e903850717ed699af35989360bedd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea3971dbd47e4b45e52baa615eb1299"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gadea3971dbd47e4b45e52baa615eb1299">ABT_thread_set_specific</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d0/d5e/group__KEY.html#ga3b2706b0ac83a0eed1409988a42d811c">ABT_key</a> key, void *value)</td></tr>
<tr class="memdesc:gadea3971dbd47e4b45e52baa615eb1299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a value with a work-unit-specific key in a work unit.  <a href="../../d0/d6d/group__ULT.html#gadea3971dbd47e4b45e52baa615eb1299">More...</a><br /></td></tr>
<tr class="separator:gadea3971dbd47e4b45e52baa615eb1299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95833ed8d21fedcf730e392f75b5bfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#gaf95833ed8d21fedcf730e392f75b5bfd">ABT_thread_get_specific</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d0/d5e/group__KEY.html#ga3b2706b0ac83a0eed1409988a42d811c">ABT_key</a> key, void **value)</td></tr>
<tr class="memdesc:gaf95833ed8d21fedcf730e392f75b5bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a value associated with a work-unit-specific key in a work unit.  <a href="../../d0/d6d/group__ULT.html#gaf95833ed8d21fedcf730e392f75b5bfd">More...</a><br /></td></tr>
<tr class="separator:gaf95833ed8d21fedcf730e392f75b5bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8093bc862fc9d54e215fd2a72ddf02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/group__ULT.html#ga5e8093bc862fc9d54e215fd2a72ddf02">ABT_thread_get_attr</a> (<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, <a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a> *attr)</td></tr>
<tr class="memdesc:ga5e8093bc862fc9d54e215fd2a72ddf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes of a work unit.  <a href="../../d0/d6d/group__ULT.html#ga5e8093bc862fc9d54e215fd2a72ddf02">More...</a><br /></td></tr>
<tr class="separator:ga5e8093bc862fc9d54e215fd2a72ddf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group is for User-level Thread (ULT). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga186008e05c04170eed9ac74808619717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga186008e05c04170eed9ac74808619717">&#9670;&nbsp;</a></span>ABT_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ABT_thread_opaque* <a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Work unit handle type. </p>
<p>A NULL handle of this type is <code>ABT_THREAD_NULL</code>.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> The value of <code>ABT_THREAD_NULL</code> is different from that of <code>ABT_TASK_NULL</code>.<br  />
 <b>[Argobots 2.0]</b> <code>ABT_TASK_NULL</code> is an alias of <code>ABT_THREAD_NULL</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. </dd>
</dl>
</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00887">887</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="ga49abe49beb3075b18fa79cf943f49219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49abe49beb3075b18fa79cf943f49219">&#9670;&nbsp;</a></span>ABT_thread_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ABT_thread_attr_opaque* <a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ULT attribute handle type. </p>
<p>A NULL handle of this type is <code>ABT_THREAD_ATTR_NULL</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00894">894</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="ga52c85a933a71326b53b59b835344747b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c85a933a71326b53b59b835344747b">&#9670;&nbsp;</a></span>ABT_thread_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../de/dab/group__UNIT.html#ga8f4ca28fbf35ddd6a922e65f49723bee">ABT_unit_id</a> <a class="el" href="../../d0/d6d/group__ULT.html#ga52c85a933a71326b53b59b835344747b">ABT_thread_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Work unit ID type. </p>
<p>This type is an alias of <code>ABT_unit_id</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00915">915</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="ga926da07d3af816e1116e5702f5ce4990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga926da07d3af816e1116e5702f5ce4990">&#9670;&nbsp;</a></span>ABT_thread_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a> <a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Work unit state type. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00899">899</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa8e839d537fd79d677108d42d4176089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8e839d537fd79d677108d42d4176089">&#9670;&nbsp;</a></span>ABT_thread_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of a work unit. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa8e839d537fd79d677108d42d4176089a87eb81bc600c1ceedc3e7c32cc7ea53a"></a>ABT_THREAD_STATE_READY&#160;</td><td class="fielddoc"><p>The work unit is ready to run. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa8e839d537fd79d677108d42d4176089ae0a7acd9ed47699f063ee2128f9f7ef6"></a>ABT_THREAD_STATE_RUNNING&#160;</td><td class="fielddoc"><p>The work unit is running. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa8e839d537fd79d677108d42d4176089a3638f9519e790388f3bbc7e35f30fece"></a>ABT_THREAD_STATE_BLOCKED&#160;</td><td class="fielddoc"><p>The work unit is blocked. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa8e839d537fd79d677108d42d4176089ade61dddc74434ee2705c536698d07149"></a>ABT_THREAD_STATE_TERMINATED&#160;</td><td class="fielddoc"><p>The work unit is terminated. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00415">415</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga218d94229458c2200f188e5ed2705afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218d94229458c2200f188e5ed2705afe">&#9670;&nbsp;</a></span>ABT_thread_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a termination request to a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga218d94229458c2200f188e5ed2705afe" title="Send a termination request to a work unit.">ABT_thread_cancel()</a></code> sends a cancellation request to the work unit <code>thread</code>. <code>thread</code> may terminate before its thread function completes.</p>
<dl class="section note"><dt>Note</dt><dd>The timing of the request fulfillment is undefined, so a program that relies on when the request is fulfilled is non-conforming.</dd></dl>
<p>Requests for work units are updated atomically.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>the</code> caller is the primary ULT.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the cancellation feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread</code> is not running, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00656">656</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga73bd1f04ce57def336cb20cdec9b14bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73bd1f04ce57def336cb20cdec9b14bd">&#9670;&nbsp;</a></span>ABT_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>thread_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>newthread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new ULT. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga73bd1f04ce57def336cb20cdec9b14bd" title="Create a new ULT.">ABT_thread_create()</a></code> creates a new ULT, given by the attributes <code>attr</code>, associates it with the pool <code>pool</code>, and returns its handle through <code>newthread</code>. This routine pushes the created ULT to the pool <code>pool</code>. The created ULT calls <code>thread_func()</code> with <code>arg</code> when it is scheduled.</p>
<p><code>attr</code> can be created by <code><a class="el" href="../../d2/df6/group__ULT__ATTR.html#ga4b1677eb8e2a300a2e94201914471776" title="Create a new ULT attribute.">ABT_thread_attr_create()</a></code>. If the user passes <code>ABT_THREAD_ATTR_NULL</code> for <code>attr</code>, the default ULT attribute is used.</p>
<dl class="section note"><dt>Note</dt><dd>To see the details of the default ULT attributes, please check <code><a class="el" href="../../d2/df6/group__ULT__ATTR.html#ga4b1677eb8e2a300a2e94201914471776" title="Create a new ULT attribute.">ABT_thread_attr_create()</a></code>.</dd></dl>
<p>This routine copies <code>attr</code>, so the user can free <code>attr</code> after this routine returns.</p>
<p>If <code>newthread</code> is <code>NULL</code>, this routine creates an unnamed ULT. The unnamed ULT is automatically released on the completion of <code>thread_func()</code>. Otherwise, <code>newthread</code> must be explicitly freed by <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code>.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>newthread</code> is set to <code>ABT_THREAD_NULL</code> if an error occurs and <code>newthread</code> is not <code>NULL</code>.<br  />
 <b>[Argobots 2.0]</b> <code>newthread</code> is not updated if an error occurs and <code>newthread</code> is not <code>NULL</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>newthread</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread_func</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_func</td><td>function to be executed by a new ULT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument for <code>thread_func()</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>ULT attribute </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newthread</td><td>ULT handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00087">87</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga364549e7e443807ef073c744428d8c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga364549e7e443807ef073c744428d8c15">&#9670;&nbsp;</a></span>ABT_thread_create_many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_create_many </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>pool_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(**)(void *)&#160;</td>
          <td class="paramname"><em>thread_func_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>arg_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>newthread_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a set of new ULTs. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga364549e7e443807ef073c744428d8c15" title="Create a set of new ULTs.">ABT_thread_create_many()</a></code> creates a set of new ULTs, i.e., <code>num_threads</code> ULTs, having the same ULT attribute <code>attr</code> and returns ULT handles to <code>newthread_list</code>. Each newly created ULT calls the corresponding function of <code>thread_func_list</code> that has <code>num_threads</code> ULT functions with the corresponding argument of <code>arg_list</code> that has <code>num_threads</code> argument pointers an argument. Each newly created ULT is pushed to the corresponding pool of <code>pool_list</code> that has <code>num_threads</code> of pools handles. That is, the <em>i</em> th ULT is pushed to <em>i</em> th pool of <code>pool_list</code> and, when scheduled, calls the <em>i</em> th function of <code>thread_func_list</code> with the <em>i</em> th argument of <code>arg_list</code>. This routine pushes newly created ULTs to pools <code>pool</code>.</p>
<p><code>attr</code> can be created by <code><a class="el" href="../../d2/df6/group__ULT__ATTR.html#ga4b1677eb8e2a300a2e94201914471776" title="Create a new ULT attribute.">ABT_thread_attr_create()</a></code>. If the user passes <code>ABT_THREAD_ATTR_NULL</code> for <code>attr</code>, the default ULT attribute is used.</p>
<dl class="section note"><dt>Note</dt><dd>To see the details of the default ULT attributes, please check <code><a class="el" href="../../d2/df6/group__ULT__ATTR.html#ga4b1677eb8e2a300a2e94201914471776" title="Create a new ULT attribute.">ABT_thread_attr_create()</a></code>.<br  />
Since this routine uses the same ULT attribute for creating all ULTs, this routine does not support a user-provided stack.</dd></dl>
<p>If <code>newthread_list</code> is <code>NULL</code>, this routine creates unnamed ULTs. The unnamed ULT is automatically released on the completion of <code>thread_func()</code>. Otherwise, the creates ULTs must be explicitly freed by <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code>.</p>
<p>This routine is deprecated because this routine does not provide a way for the user to keep track of an error that happens during this routine. The user should use <code><a class="el" href="../../d0/d6d/group__ULT.html#ga73bd1f04ce57def336cb20cdec9b14bd" title="Create a new ULT.">ABT_thread_create()</a></code> instead.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If any error happens in this routine, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_threads</td><td>number of array elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool_list</td><td>array of pool handles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_func_list</td><td>array of ULT functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg_list</td><td>array of arguments for each ULT function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>ULT attribute </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newthread_list</td><td>array of ULT handles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00250">250</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga503c1948f3f577d2b079308364bf5158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503c1948f3f577d2b079308364bf5158">&#9670;&nbsp;</a></span>ABT_thread_create_on_xstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_create_on_xstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/def/group__ES.html#gad79a2fa8571915e3cfcd1383fcebf6f3">ABT_xstream</a>&#160;</td>
          <td class="paramname"><em>xstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>thread_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>newthread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new ULT associated with an execution stream. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga503c1948f3f577d2b079308364bf5158" title="Create a new ULT associated with an execution stream.">ABT_thread_create_on_xstream()</a></code> creates a new ULT, given by the attributes <code>attr</code>, associates it with the first pool of the main scheduler of the execution stream <code>xstream</code>, and returns its handle through <code>newthread</code>. This routine pushes the created ULT to the pool <code>pool</code>. The created ULT calls <code>thread_func()</code> with <code>arg</code> when it is scheduled.</p>
<p><code>attr</code> can be created by <code><a class="el" href="../../d2/df6/group__ULT__ATTR.html#ga4b1677eb8e2a300a2e94201914471776" title="Create a new ULT attribute.">ABT_thread_attr_create()</a></code>. If the user passes <code>ABT_THREAD_ATTR_NULL</code> for <code>attr</code>, the default ULT attribute is used.</p>
<dl class="section note"><dt>Note</dt><dd>To see the details of the default ULT attributes, please check <code><a class="el" href="../../d2/df6/group__ULT__ATTR.html#ga4b1677eb8e2a300a2e94201914471776" title="Create a new ULT attribute.">ABT_thread_attr_create()</a></code>.</dd></dl>
<p>This routine copies <code>attr</code>, so the user can free <code>attr</code> after this routine returns.</p>
<p>If <code>newthread</code> is <code>NULL</code>, this routine creates an unnamed ULT. The unnamed ULT is automatically released on the completion of <code>thread_func()</code>. Otherwise, <code>newthread</code> must be explicitly freed by <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code>.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>newthread</code> is set to <code>ABT_THREAD_NULL</code> if an error occurs and <code>newthread</code> is not <code>NULL</code>.<br  />
 <b>[Argobots 2.0]</b> <code>newthread</code> is not updated if an error occurs and <code>newthread</code> is not <code>NULL</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>newthread</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_XSTREAM</code> is returned if <code>xstream</code> is <code>ABT_XSTREAM_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread_func</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xstream</td><td>execution stream handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_func</td><td>function to be executed by a new ULT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument for <code>thread_func()</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>ULT attribute </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newthread</td><td>ULT handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00167">167</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga40988251b2cc313fc60e4058c3d9021d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40988251b2cc313fc60e4058c3d9021d">&#9670;&nbsp;</a></span>ABT_thread_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two work unit handles for equality. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga40988251b2cc313fc60e4058c3d9021d" title="Compare two work unit handles for equality.">ABT_thread_equal()</a></code> compares two work unit handles <code>thread1</code> and <code>thread2</code> for equality.</p>
<p>This routine is deprecated since its behavior is the same as comparing values of <code>ABT_thread</code> handles except for handling <code>ABT_THREAD_NULL</code> and <code>ABT_TASK_NULL</code>. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (thread1 == <a class="code" href="../../d5/d7d/abt_8h.html#aabf134f2165a5d15ea5bd063b982d8a6">ABT_THREAD_NULL</a> || thread1 == <a class="code" href="../../d5/d7d/abt_8h.html#acedaaeb67b83967cc9129e0906f38e93">ABT_TASK_NULL</a>) {</div>
<div class="line">  *result = (thread2 == <a class="code" href="../../d5/d7d/abt_8h.html#aabf134f2165a5d15ea5bd063b982d8a6">ABT_THREAD_NULL</a> || thread2 == <a class="code" href="../../d5/d7d/abt_8h.html#acedaaeb67b83967cc9129e0906f38e93">ABT_TASK_NULL</a>)</div>
<div class="line">            ? <a class="code" href="../../d5/d7d/abt_8h.html#a1839f64e5a2462a68ffd82ba94213582">ABT_TRUE</a> : <a class="code" href="../../d5/d7d/abt_8h.html#aedde437380ced4813c3c36d97e926a25">ABT_FALSE</a>;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  *result = (thread1 == thread2) ? <a class="code" href="../../d5/d7d/abt_8h.html#a1839f64e5a2462a68ffd82ba94213582">ABT_TRUE</a> : <a class="code" href="../../d5/d7d/abt_8h.html#aedde437380ced4813c3c36d97e926a25">ABT_FALSE</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread1</code> or <code>thread2</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread1</code> or <code>thread2</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If <code>result</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread1</td><td>work unit handle 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread2</td><td>work unit handle 2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>result (<code>ABT_TRUE:</code> same, <code>ABT_FALSE:</code> not same) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01853">1853</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga2a23f817ff7a6e7dc0ec95b474fd7404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a23f817ff7a6e7dc0ec95b474fd7404">&#9670;&nbsp;</a></span>ABT_thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate a calling ULT. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga2a23f817ff7a6e7dc0ec95b474fd7404" title="Terminate a calling ULT.">ABT_thread_exit()</a></code> terminates the calling ULT. This routine does not return if it succeeds.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> This routine returns <code>ABT_ERR_UNINITIALIZED</code> if Argobots is not initialized.<br  />
 <b>[Argobots 2.0]</b> The results are undefined if Argobots is not initialized. <dl class="section user">
<dt>Rationale</dt>
<dd>From Argobots 2.0, all the Argobots routines that are not explicitly noted do not check if Argobots is initialized. This omission can reduce the branches that are mostly unnecessary. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in a ULT context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_ERR_INV_XSTREAM</code> is returned if the caller is an external thread.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if the caller is a tasklet.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>the</code> caller is the primary ULT.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_UNINITIALIZED</code> is returned if the Argobots runtime is not initialized.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd><b>[Argobots 2.0]</b> If Argobots is not initialized, the results are undefined.<br  />
 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00609">609</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaf31f748bfd565f97aa8ebabb89e9b632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31f748bfd565f97aa8ebabb89e9b632">&#9670;&nbsp;</a></span>ABT_thread_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code> deallocates the resource used for the thread <code>thread</code>. If <code>thread</code> is a ULT, <code>thread</code> is set to <code>ABT_THREAD_NULL</code>. If <code>thread</code> is a tasklet, <code>thread</code> is set to <code>ABT_TASK_NULL</code>. If <code>thread</code> is still running, this routine will be blocked on <code>thread</code> until <code>thread</code> terminates.</p>
<dl class="section note"><dt>Note</dt><dd>Because an unnamed work unit will be freed immediately after its termination, an unnamed work unit cannot be freed by this routine.<br  />
This routine cannot free the calling work unit.<br  />
This routine cannot free the main ULT or the main scheduler ULT.<br  />
Only one caller can join or free the same work unit.</dd></dl>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> points to <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the caller.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the primary ULT.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread</code> is <code>NULL</code>, the results are undefined.<br  />
If <code>thread</code>, <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf5275b75a5184bca258e803370e44bea" title="Wait for a work unit to terminate.">ABT_thread_join()</a></code> and <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code> is blocked on by , the results are undefined.<br  />
If <code>thread</code> is accessed after calling this routine, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00413">413</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga51f99be6079db81a6c651231096788d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f99be6079db81a6c651231096788d3">&#9670;&nbsp;</a></span>ABT_thread_free_many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_free_many </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>thread_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a set of work units. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga51f99be6079db81a6c651231096788d3" title="Free a set of work units.">ABT_thread_free_many()</a></code> deallocates a set of work units listed in <code>thread_list</code> that has <code>num_threads</code> work unit handles. Each handle referenced by <code>thread_list</code> is set to <code>ABT_THRAED_NULL</code>.</p>
<p>This routine is deprecated because this routine does not provide a way for the user to keep track of an error that happens during this routine. The user should use <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code> instead.</p>
<p>Management of states of work units is performed atomically.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as an element of <code>thread_list</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as an element of <code>thread_list</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If any error happens in this routine, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_threads</td><td>the number of array elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thread_list</td><td>array of work unit handles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00471">471</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga03e903850717ed699af35989360bedd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03e903850717ed699af35989360bedd8">&#9670;&nbsp;</a></span>ABT_thread_get_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an argument for a work unit function of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga03e903850717ed699af35989360bedd8" title="Retrieve an argument for a work unit function of a work unit.">ABT_thread_get_arg()</a></code> returns the argument for the work unit function of the work unit <code>thread</code> through <code>arg</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>arg</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arg</td><td>argument for the work unit function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01998">1998</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga5e8093bc862fc9d54e215fd2a72ddf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e8093bc862fc9d54e215fd2a72ddf02">&#9670;&nbsp;</a></span>ABT_thread_get_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_attr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga49abe49beb3075b18fa79cf943f49219">ABT_thread_attr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get attributes of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga5e8093bc862fc9d54e215fd2a72ddf02" title="Get attributes of a work unit.">ABT_thread_get_attr()</a></code> returns a newly created attribute object that is copied from the attributes of the work unit <code>thread</code> through <code>attr</code>. Attribute values of <code>attr</code> may be different from those used on the creation of <code>thread</code>. Since this routine allocates a ULT attribute object, it is the user's responsibility to free <code>attr</code> after its use.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> If <code>thread</code> is a tasklet, this routine returns <code>ABT_ERR_INV_THREAD</code>.<br  />
 <b>[Argobots 2.0]</b> If <code>thread</code> is a tasklet, this routine sets <code>attr</code> to a properly translated ULT attributes and returns <code>ABT_SUCCESS</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is a tasklet.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>attr</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr</td><td>ULT attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l02124">2124</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaa31b2d9339e8675680d9e776108c9681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa31b2d9339e8675680d9e776108c9681">&#9670;&nbsp;</a></span>ABT_thread_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga8f4ca28fbf35ddd6a922e65f49723bee">ABT_unit_id</a> *&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gaa31b2d9339e8675680d9e776108c9681" title="Get ID of a work unit.">ABT_thread_get_id()</a></code> returns the ID of the work unit <code>a</code> thread through <code>thread_id</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread_id</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thread_id</td><td>work unit ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01928">1928</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga1d0baa47137ae3c140ff3c125b8a21ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0baa47137ae3c140ff3c125b8a21ed">&#9670;&nbsp;</a></span>ABT_thread_get_last_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_last_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last pool of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga1d0baa47137ae3c140ff3c125b8a21ed" title="Get the last pool of a work unit.">ABT_thread_get_last_pool()</a></code> returns the last pool associated with the work unit <code>thread</code> through <code>pool</code>. If <code>thread</code> is not associated with any pool, <code>pool</code> is set to <code>ABT_POOL_NULL</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The returned <code>pool</code> may point to an invalid handle if the last pool associated with <code>thread</code> has already been freed.</dd></dl>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>pool</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pool</td><td>the last pool associated with <code>thread</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00874">874</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga4bd69e6f45c2c4578bd736c197c5d2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bd69e6f45c2c4578bd736c197c5d2e6">&#9670;&nbsp;</a></span>ABT_thread_get_last_pool_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_last_pool_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last pool's ID of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga4bd69e6f45c2c4578bd736c197c5d2e6" title="Get the last pool&#39;s ID of a work unit.">ABT_thread_get_last_pool_id()</a></code> returns the ID of the last pool associated with the work unit <code>thread</code> through <code>id</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The returned <code>pool</code> may point to an invalid handle if the last pool associated with <code>thread</code> has already been freed.</dd></dl>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>id</code> is <code>NULL</code>, the results are undefined.<br  />
If the last pool associated with <code>thread</code> has already been freed, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>ID of the last pool associated with <code>thread</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00914">914</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gabe017b55ac9641198e73cdb99cbce8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe017b55ac9641198e73cdb99cbce8e9">&#9670;&nbsp;</a></span>ABT_thread_get_last_xstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_last_xstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/def/group__ES.html#gad79a2fa8571915e3cfcd1383fcebf6f3">ABT_xstream</a> *&#160;</td>
          <td class="paramname"><em>xstream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an execution stream associated with a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gabe017b55ac9641198e73cdb99cbce8e9" title="Get an execution stream associated with a work unit.">ABT_thread_get_last_xstream()</a></code> returns the last execution stream associated with the work unit <code>thread</code> through <code>xstream</code>. If <code>thread</code> is not associated with any execution stream, <code>xstream</code> is set to <code>ABT_XSTREAM_NULL</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The returned <code>xstream</code> may point to an invalid handle if the last execution stream associated with <code>thread</code> has already been freed.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>xstream</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xstream</td><td>execution stream handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00793">793</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaf95833ed8d21fedcf730e392f75b5bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95833ed8d21fedcf730e392f75b5bfd">&#9670;&nbsp;</a></span>ABT_thread_get_specific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_specific </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d5e/group__KEY.html#ga3b2706b0ac83a0eed1409988a42d811c">ABT_key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a value associated with a work-unit-specific key in a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gaf95833ed8d21fedcf730e392f75b5bfd" title="Get a value associated with a work-unit-specific key in a work unit.">ABT_thread_get_specific()</a></code> returns the value of the work-unit-specific data key <code>key</code> in the work unit <code>thread</code> through <code>value</code>. If <code>thread</code> has never set a value for <code>key</code>, this routine sets <code>value</code> to <code>NULL</code>.</p>
<p>Work-unit-specific values associated with a work-unit-specific data key are read and updated atomically.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_KEY</code> is returned if <code>key</code> is <code>ABT_KEY_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>value</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>work-unit-specific data key handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l02080">2080</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gae1515f2d99034a3969855ebfbe1e0808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1515f2d99034a3969855ebfbe1e0808">&#9670;&nbsp;</a></span>ABT_thread_get_stacksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_stacksize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>stacksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a stack size of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gae1515f2d99034a3969855ebfbe1e0808" title="Get a stack size of a work unit.">ABT_thread_get_stacksize()</a></code> returns the stack size of the work unit <code>thread</code> in bytes through <code>stacksize</code>. If <code>thread</code> does not have a stack managed by the Argobots runtime (e.g., the tasklet or the primary ULT), <code>stacksize</code> is set to 0.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>stacksize</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stacksize</td><td>stack size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01889">1889</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga7c9d02c8bdd6a75538b7301c9db0a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c9d02c8bdd6a75538b7301c9db0a485">&#9670;&nbsp;</a></span>ABT_thread_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_get_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#gaa8e839d537fd79d677108d42d4176089">ABT_thread_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a state of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga7c9d02c8bdd6a75538b7301c9db0a485" title="Get a state of a work unit.">ABT_thread_get_state()</a></code> returns the state of the work unit <code>thread</code> through <code>state</code>.</p>
<p>Management of states of work units is performed atomically.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>thread</code> is a tasklet, <code>ABT_task_state</code> is converted to the corresponding <code>ABT_thread_state</code>.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>state</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>state of <code>thread</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00834">834</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga68dc0d52cae397a965818516b34e0e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68dc0d52cae397a965818516b34e0e09">&#9670;&nbsp;</a></span>ABT_thread_is_migratable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_is_migratable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *&#160;</td>
          <td class="paramname"><em>is_migratable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the migratability of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga68dc0d52cae397a965818516b34e0e09" title="Get the migratability of a work unit.">ABT_thread_is_migratable()</a></code> returns the migratability of the work unit <code>thread</code> through <code>is_migratable</code>. If <code>thread</code> is migratable, <code>is_migratable</code> is set to <code>ABT_TRUE</code>. Otherwise, <code>is_migratable</code> is set to <code>ABT_FALSE</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>is_migratable</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_migratable</td><td>result (<code>ABT_TRUE:</code> migratable, <code>ABT_FALSE:</code> not) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01727">1727</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga748ab622b69796462333725a2513db1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748ab622b69796462333725a2513db1a">&#9670;&nbsp;</a></span>ABT_thread_is_primary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_is_primary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *&#160;</td>
          <td class="paramname"><em>is_primary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a work unit is the primary ULT. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga748ab622b69796462333725a2513db1a" title="Check if a work unit is the primary ULT.">ABT_thread_is_primary()</a></code> checks if the work unit <code>thread</code> is the primary ULT and returns the result through <code>is_primary</code>. If <code>thread</code> is the main ULT, <code>is_primary</code> is set to <code>ABT_TRUE</code>. Otherwise, <code>is_primary</code> is set to <code>ABT_FALSE</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>flag</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_primary</td><td>result (<code>ABT_TRUE:</code> primary ULT, <code>ABT_FALSE:</code> not) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01769">1769</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gacf91b0c5c7252f6e57ef253583635e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf91b0c5c7252f6e57ef253583635e7c">&#9670;&nbsp;</a></span>ABT_thread_is_unnamed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_is_unnamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> *&#160;</td>
          <td class="paramname"><em>is_unnamed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a work unit is unnamed. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga748ab622b69796462333725a2513db1a" title="Check if a work unit is the primary ULT.">ABT_thread_is_primary()</a></code> checks if the work unit <code>thread</code> is unnamed and returns the result through <code>flag</code>. If <code>thread</code> is unnamed, <code>flag</code> is set to <code>ABT_TRUE</code>. Otherwise, <code>flag</code> is set to <code>ABT_FALSE</code>.</p>
<dl class="section note"><dt>Note</dt><dd>A handle of an unnamed work unit can be obtained by, for example, running <code><a class="el" href="../../d0/d6d/group__ULT.html#ga994a8e23d9c6ace41779d8ce2585ae88" title="Get the calling work unit.">ABT_thread_self()</a></code> on an unnamed work unit.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>flag</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_unnamed</td><td>result (<code>ABT_TRUE:</code> unnamed, <code>ABT_FALSE:</code> not) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01806">1806</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaf5275b75a5184bca258e803370e44bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5275b75a5184bca258e803370e44bea">&#9670;&nbsp;</a></span>ABT_thread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a work unit to terminate. </p>
<p>The caller of <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf5275b75a5184bca258e803370e44bea" title="Wait for a work unit to terminate.">ABT_thread_join()</a></code> waits for the work unit <code>thread</code> until <code>thread</code> terminates.</p>
<dl class="section note"><dt>Note</dt><dd>Because an unnamed work unit will be freed immediately after its termination, an unnamed work unit cannot be joined by this routine.<br  />
This routine cannot join the calling work unit.<br  />
This routine cannot join the main ULT or the main scheduler ULT.<br  />
Only one caller can join or free the same work unit.</dd></dl>
<p>Management of states of work units is performed atomically.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the caller.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the primary ULT.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread</code>, <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf5275b75a5184bca258e803370e44bea" title="Wait for a work unit to terminate.">ABT_thread_join()</a></code> and <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code> is blocked on by , the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00526">526</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga7c23f76b44d29ec70a18759ba019b050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c23f76b44d29ec70a18759ba019b050">&#9670;&nbsp;</a></span>ABT_thread_join_many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_join_many </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>thread_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a set of work units to terminate. </p>
<p>The caller of <code><a class="el" href="../../d0/d6d/group__ULT.html#ga7c23f76b44d29ec70a18759ba019b050" title="Wait for a set of work units to terminate.">ABT_thread_join_many()</a></code> waits for all the work units in <code>thread_list</code> that has <code>num_threads</code> work unit handles until all the work units in <code>thread_list</code> terminate.</p>
<p>This routine is deprecated because this routine does not provide a way for the user to keep track of an error that happens during this routine. The user should use <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf5275b75a5184bca258e803370e44bea" title="Wait for a work unit to terminate.">ABT_thread_join()</a></code> instead.</p>
<p>Management of states of work units is performed atomically.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as an element of <code>thread_list</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as an element of <code>thread_list</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If any error happens in this routine, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_threads</td><td>the number of ULTs to join </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_list</td><td>array of target ULT handles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00573">573</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaa2646bfbabf0df851f964ae38a92804a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2646bfbabf0df851f964ae38a92804a">&#9670;&nbsp;</a></span>ABT_thread_migrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_migrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a migration of a work unit to any available execution streams. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gaa2646bfbabf0df851f964ae38a92804a" title="Request a migration of a work unit to any available execution streams.">ABT_thread_migrate()</a></code> requests a migration of the work unit <code>thread</code> to one of the execution streams. The last execution stream of <code>thread</code> is not chosen as the target execution stream. The previous migration request will be overwritten by the new migration request. The requested work unit may be migrated before its work unit function completes.</p>
<dl class="section note"><dt>Note</dt><dd>The timing of the request fulfillment is undefined, so a program that relies on when the request is fulfilled is non-conforming.</dd></dl>
<p>Requests for work units are updated atomically.</p>
<p>It is the user's responsibility to keep all the execution streams, the main schedulers, and their associated pools until the migration process completes or <code>thread</code> is freed, whichever is earlier.</p>
<p>This routine is deprecated because this routine will not choose an execution stream that is expected by the user while this routine is significantly restrictive. The user should use other migration functions instead.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the runtime finds that <code>thread</code> is terminated.<br  />
 <b>[Argobots 1.1]</b> The results are undefined if <code>thread</code> is terminated. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Proper implementation of this check is expensive since it requires atomic management of a work unit state and a request. Argobots 1.1 eliminates this check. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is not migratable.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
<code>ABT_ERR_MIGRATION_NA</code> is returned if no execution stream for migration exists.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If any execution stream, any main scheduler of the execution streams, or any pool associated with the main schedulers is freed before the migration process completes or <code>thread</code> is freed, whichever is earlier, the results are undefined.<br  />
If <code>thread</code> is terminated, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01492">1492</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga0414ecaedd36796a643e055bebafab99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0414ecaedd36796a643e055bebafab99">&#9670;&nbsp;</a></span>ABT_thread_migrate_to_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_migrate_to_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a migration of a work unit to a specific pool. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga0414ecaedd36796a643e055bebafab99" title="Request a migration of a work unit to a specific pool.">ABT_thread_migrate_to_pool()</a></code> requests a migration of the work unit <code>thread</code> to the pool <code>pool</code>. The previous migration request will be overwritten by the new migration request. The requested work unit may be migrated before its work unit function completes.</p>
<dl class="section note"><dt>Note</dt><dd>The timing of the request fulfillment is undefined, so a program that relies on when the request is fulfilled is non-conforming.</dd></dl>
<p>Requests for work units are updated atomically.</p>
<p>It is the user's responsibility to keep <code>pool</code> until the migration process completes or <code>thread</code> is freed, whichever is earlier.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the runtime finds that <code>thread</code> is terminated.<br  />
 <b>[Argobots 1.1]</b> The results are undefined if <code>thread</code> is terminated. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Proper implementation of this check is expensive since it requires atomic management of a work unit state and a request. Argobots 1.1 eliminates this check. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is not migratable.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_MIGRATION_TARGET</code> is returned if <code>thread</code> is associated with <code>pool</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>pool</code> is freed before the migration process completes or <code>thread</code> is freed, whichever is earlier, the results are undefined.<br  />
If <code>thread</code> is terminated, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01414">1414</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga8ccc5f3082e1608f555dc06e9a70d202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccc5f3082e1608f555dc06e9a70d202">&#9670;&nbsp;</a></span>ABT_thread_migrate_to_sched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_migrate_to_sched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d83/group__SCHED.html#gadf0a564b506bb4a288f49cbfd3116025">ABT_sched</a>&#160;</td>
          <td class="paramname"><em>sched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a migration of a work unit to a specific scheduler. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga8ccc5f3082e1608f555dc06e9a70d202" title="Request a migration of a work unit to a specific scheduler.">ABT_thread_migrate_to_sched()</a></code> requests a migration of the work unit <code>thread</code> to any pool associated with the scheduler <code>sched</code>. The previous migration request is overwritten by the new migration request. The requested work unit may be migrated before its work unit function completes.</p>
<dl class="section note"><dt>Note</dt><dd>The timing of the request fulfillment is undefined, so a program that relies on when the request is fulfilled is non-conforming.</dd></dl>
<p>Requests for work units are updated atomically.</p>
<p>It is the user's responsibility to keep <code>sched</code> and its associated pools until the migration process completes or <code>thread</code> is freed, whichever is earlier.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the runtime finds that <code>thread</code> is terminated.<br  />
 <b>[Argobots 1.1]</b> The results are undefined if <code>thread</code> is terminated. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Proper implementation of this check is expensive since it requires atomic management of a work unit state and a request. Argobots 1.1 eliminates this check. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is not migratable.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
<code>ABT_ERR_INV_SCHED</code> is returned if <code>sched</code> is <code>ABT_SCHED_NULL</code>.<br  />
<code>ABT_ERR_MIGRATION_TARGET</code> is returned if <code>thread</code> is associated with any pool associated with <code>sched</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>sched</code> or any pool associated with <code>sched</code> is freed before the migration process completes or <code>thread</code> is freed, whichever is earlier, the results are undefined.<br  />
If <code>thread</code> is terminated, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sched</td><td>scheduler handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01331">1331</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gafa5495103e2bf9968136c381634fc242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5495103e2bf9968136c381634fc242">&#9670;&nbsp;</a></span>ABT_thread_migrate_to_xstream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_migrate_to_xstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/def/group__ES.html#gad79a2fa8571915e3cfcd1383fcebf6f3">ABT_xstream</a>&#160;</td>
          <td class="paramname"><em>xstream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a migration of a work unit to a specific execution stream. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gafa5495103e2bf9968136c381634fc242" title="Request a migration of a work unit to a specific execution stream.">ABT_thread_migrate_to_xstream()</a></code> requests a migration of the work unit <code>thread</code> to any pool associated with the main scheduler of execution stream <code>xstream</code>. The previous migration request is overwritten by the new migration request. The requested work unit may be migrated before its work unit function completes.</p>
<dl class="section note"><dt>Note</dt><dd>The timing of the request fulfillment is undefined, so a program that relies on when the request is fulfilled is non-conforming.</dd></dl>
<p>Requests for work units are updated atomically.</p>
<p>It is the user's responsibility to keep <code>xstream</code>, its main scheduler, and its associated pools until the migration process completes or <code>thread</code> is freed, whichever is earlier.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the runtime finds that <code>thread</code> is terminated.<br  />
 <b>[Argobots 1.1]</b> The results are undefined if <code>thread</code> is terminated. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Proper implementation of this check is expensive since it requires atomic management of a work unit state and a request. Argobots 1.1 eliminates this check. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is not migratable.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
<code>ABT_ERR_INV_XSTREAM</code> is returned if <code>xstream</code> is <code>ABT_XSTREAM_NULL</code>.<br  />
<code>ABT_ERR_MIGRATION_TARGET</code> is returned if <code>thread</code> is associated with any pool associated with the main scheduler of <code>xstream</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>xstream</code>, the main scheduler of <code>xstream</code>, or any pool associated with the main scheduler of <code>xstream</code> is freed before the migration process completes or <code>thread</code> is freed, whichever is earlier, the results are undefined.<br  />
If <code>thread</code> is terminated, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xstream</td><td>execution stream handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01245">1245</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaef94b0efbf392fdc4bd5d04f67f22a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef94b0efbf392fdc4bd5d04f67f22a5e">&#9670;&nbsp;</a></span>ABT_thread_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a ULT. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gaef94b0efbf392fdc4bd5d04f67f22a5e" title="Resume a ULT.">ABT_thread_resume()</a></code> resumes the ULT <code>thread</code> blocked by <code>ABT_thread_suspend()</code> schedulable by making <code>thread</code> ready and pushing <code>thread</code> to its associated pool.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>ABT_ERR_THREAD</code> is returned if <code>thread</code> is not suspended.<br  />
 <b>[Argobots 2.0]</b> The results are undefined if <code>thread</code> is not suspended. <dl class="section user">
<dt>Rationale</dt>
<dd>This check of the current implementation is not atomic while making this check atomic is expensive. From Argobots 2.0, it becomes the user's responsibility to guarantee that <code>thread</code> has been suspended. Note that Argobots 1.x does not perform this check atomically, so the user may not concurrently call <code><a class="el" href="../../d0/d6d/group__ULT.html#gaef94b0efbf392fdc4bd5d04f67f22a5e" title="Resume a ULT.">ABT_thread_resume()</a></code> for the same ULT. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is a tasklet.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_THREAD</code> is returned if <code>thread</code> is not suspended.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
<b>[Argobots 2.0]</b> If <code>thread</code> is not suspended, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>ULT handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01174">1174</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gaf3c80cb3fe88262dd64e42ec63191d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c80cb3fe88262dd64e42ec63191d4e">&#9670;&nbsp;</a></span>ABT_thread_revive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_revive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>thread_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Revive a terminated work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gaf3c80cb3fe88262dd64e42ec63191d4e" title="Revive a terminated work unit.">ABT_thread_revive()</a></code> revives the work unit <code>thread</code> with <code>thread_func</code> and <code>arg</code>. This routine does not change the attributes of <code>thread</code>. The revived work unit is pushed to <code>pool</code>. Although this routine takes a pointer of <code>ABT_thread</code>, the handle of <code>thread</code> is not updated by this routine.</p>
<p><code>thread</code> must be a terminated work unit that has not been freed. A work unit that is blocked on by another caller may not be revived.</p>
<dl class="section note"><dt>Note</dt><dd>Because an unnamed work unit will be freed immediately after its termination, an unnamed work unit cannot be revived.</dd></dl>
<p>Management of states of work units is performed atomically.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> points to <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is not terminated.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread_func</code> is <code>NULL</code>, the results are undefined.<br  />
If <code>thread</code> is <code>NULL</code>, the results are undefined.<br  />
If <code>thread</code>, <code><a class="el" href="../../d0/d6d/group__ULT.html#gaf31f748bfd565f97aa8ebabb89e9b632" title="Free a work unit.">ABT_thread_free()</a></code> is blocked on by , the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_func</td><td>function to be executed by the work unit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument for <code>thread_func()</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00352">352</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d3f/task_8c_source.html#l00153">ABT_task_revive()</a>.</p>

</div>
</div>
<a id="ga994a8e23d9c6ace41779d8ce2585ae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994a8e23d9c6ace41779d8ce2585ae88">&#9670;&nbsp;</a></span>ABT_thread_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_self </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the calling work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga994a8e23d9c6ace41779d8ce2585ae88" title="Get the calling work unit.">ABT_thread_self()</a></code> returns the handle of the calling work unit through <code>thread</code>.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><p class="startdd"><b>[Argobots 1.x]</b> If a tasklet calls this routine, <code>ABT_ERR_INV_THREAD</code> is returned.<br  />
 <b>[Argobots 2.0]</b> A tasklet may call this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. </dd>
</dl>
<p class="interdd"><b>[Argobots 1.x]</b> This routine returns <code>ABT_ERR_UNINITIALIZED</code> if Argobots is not initialized.<br  />
 <b>[Argobots 2.0]</b> The results are undefined if Argobots is not initialized. </p><dl class="section user">
<dt>Rationale</dt>
<dd>From Argobots 2.0, all the Argobots routines that are not explicitly noted do not check if Argobots is initialized. This omission can reduce the branches that are mostly unnecessary. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.x]</b> <code>thread</code> is set to <code>ABT_THREAD_NULL</code> if an error occurs.<br  />
 <b>[Argobots 2.0]</b> <code>thread</code> is not updated if an error occurs. </p><dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>thread</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd><b>[Argobots 1.x]</b> This routine can be called in a ULT context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.<br  />
<b>[Argobots 2.0]</b> This routine can be called in a ULT context and a tasklet context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_XSTREAM</code> is returned if the caller is an external thread.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the caller is a tasklet.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_UNINITIALIZED</code> is returned if the Argobots runtime is not initialized.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If <code>thread</code> is <code>NULL</code>, the results are undefined.<br  />
<b>[Argobots 2.0]</b> If Argobots is not initialized, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00704">704</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga425f9c7a9f82efc642a9feb3d1c569c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425f9c7a9f82efc642a9feb3d1c569c6">&#9670;&nbsp;</a></span>ABT_thread_self_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_self_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga8f4ca28fbf35ddd6a922e65f49723bee">ABT_unit_id</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID of the calling work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga425f9c7a9f82efc642a9feb3d1c569c6" title="Get ID of the calling work unit.">ABT_thread_self_id()</a></code> returns the ID of the calling work unit through <code>id</code>.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><p class="startdd"><b>[Argobots 1.x]</b> If a tasklet calls this routine, <code>ABT_ERR_INV_THREAD</code> is returned.<br  />
 <b>[Argobots 2.0]</b> A tasklet may call this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.x]</b> This routine returns <code>ABT_ERR_UNINITIALIZED</code> if Argobots is not initialized.<br  />
 <b>[Argobots 2.0]</b> The results are undefined if Argobots is not initialized. </p><dl class="section user">
<dt>Rationale</dt>
<dd>From Argobots 2.0, all the Argobots routines that are not explicitly noted do not check if Argobots is initialized. This omission can reduce the branches that are mostly unnecessary. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd><b>[Argobots 1.x]</b> This routine can be called in a ULT context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.<br  />
<b>[Argobots 2.0]</b> This routine can be called in a ULT context and a tasklet context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_XSTREAM</code> is returned if the caller is an external thread.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the caller is a tasklet.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_UNINITIALIZED</code> is returned if the Argobots runtime is not initialized.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If <code>id</code> is <code>NULL</code>, the results are undefined.<br  />
<b>[Argobots 2.0]</b> If Argobots is not initialized, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>ID of the calling work unit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00750">750</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga5048aacb8a6d3c91ddaf6c933d008415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5048aacb8a6d3c91ddaf6c933d008415">&#9670;&nbsp;</a></span>ABT_thread_set_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_set_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an argument for a work unit function of a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga5048aacb8a6d3c91ddaf6c933d008415" title="Set an argument for a work unit function of a work unit.">ABT_thread_set_arg()</a></code> sets the argument <code>arg</code> for the work unit function of the work unit <code>thread</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument for the work unit function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01963">1963</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga15349fa8b9aa7e6f673f48e74ae75fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15349fa8b9aa7e6f673f48e74ae75fc8">&#9670;&nbsp;</a></span>ABT_thread_set_associated_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_set_associated_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an associated pool for the target work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga15349fa8b9aa7e6f673f48e74ae75fc8" title="Set an associated pool for the target work unit.">ABT_thread_set_associated_pool()</a></code> changes the associated pool of the work unit <code>thread</code> to the pool <code>pool</code>. This routine must be called after <code>thread</code> is popped from its original associated pool (i.e., <code>thread</code> must not be in any pool), which is the pool where <code>thread</code> was residing. This routine does not push <code>thread</code> to <code>pool</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>thread</code> is in a pool, the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l00953">953</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gab6379e8104b5f37a3a0a552a6973d613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6379e8104b5f37a3a0a552a6973d613">&#9670;&nbsp;</a></span>ABT_thread_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a> thread, void *cb_arg)&#160;</td>
          <td class="paramname"><em>cb_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback function in a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gab6379e8104b5f37a3a0a552a6973d613" title="Set a callback function in a work unit.">ABT_thread_set_callback()</a></code> sets the callback function <code>cb_func()</code> and its argument <code>cb_arg</code> in the work unit <code>thread</code>. If <code>cb_func</code> is not <code>NULL</code>, <code>cb_func()</code> is called with <code>cb_arg</code> as an argument on the migration of <code>thread</code>. If <code>cb_func</code> is <code>NULL</code>, <code>thread</code> not call a callback function on its migration.</p>
<p>If the callback function is set, a callback function <code>cb_func()</code> will be called every time on migration of the associated work unit. The first argument of <code>cb_arg()</code> is the handle of a migrated work unit. The second argument is <code>cb_arg</code> passed to this routine. The caller of the callback function is undefined, so a program that relies on the caller is non-conforming.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If the internal state of the Argobots is changed in <code>cb_func()</code>, the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_func</td><td>callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>argument for <code>cb_func()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01608">1608</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga5e29ca342b00b88a18303f1c4a09905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e29ca342b00b88a18303f1c4a09905b">&#9670;&nbsp;</a></span>ABT_thread_set_migratable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_set_migratable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a>&#160;</td>
          <td class="paramname"><em>migratable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the migratability in a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga5e29ca342b00b88a18303f1c4a09905b" title="Set the migratability in a work unit.">ABT_thread_set_migratable()</a></code> sets the migratability in the work unit <code>thread</code>. If <code>migratable</code> is <code>ABT_TRUE</code>, <code>thread</code> becomes migratable. Otherwise, <code>thread</code> becomes unmigratable.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The user cannot pass a tasklet handle as <code>thread</code>.<br  />
 <b>[Argobots 1.1]</b> This routine accepts a tasklet handle as <code>thread</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 2.0 integrates a ULT and a tasklet into a single thread concept to make the API more general. Argobots 1.1 has introduced this change since this change does not break the compatibility of API and ABI of Argobots 1.0. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> If <code>thread</code> is the primary ULT or the work unit associated with the main scheduler, this routine has no effect and returns <code>ABT_SUCCESS</code>.<br  />
 <b>[Argobots 2.0]</b> If <code>thread</code> is the primary ULT or the work unit associated with the main scheduler, this routine returns <code>ABT_ERR_INV_THREAD</code>. <dl class="section user">
<dt>Rationale</dt>
<dd>The original behavior is error-prone since this routine does nothing but returns <code>ABT_SUCCESS</code>. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<code>ABT_ERR_FEATURE_NA</code> is returned if the migration feature is not supported.<br  />
<b>[Argobots 2.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the primary ULT.<br  />
<b>[Argobots 2.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the work unit of the main scheduler.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>migratable</code> is neither <code>ABT_TRUE</code> nor <code>ABT_FALSE</code>, the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">migratable</td><td>migratability flag (<code>ABT_TRUE:</code> migratable, <code>ABT_FALSE:</code> not) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01670">1670</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="gadea3971dbd47e4b45e52baa615eb1299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea3971dbd47e4b45e52baa615eb1299">&#9670;&nbsp;</a></span>ABT_thread_set_specific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_set_specific </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d5e/group__KEY.html#ga3b2706b0ac83a0eed1409988a42d811c">ABT_key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a value with a work-unit-specific key in a work unit. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#gadea3971dbd47e4b45e52baa615eb1299" title="Set a value with a work-unit-specific key in a work unit.">ABT_thread_set_specific()</a></code> associates the value <code>value</code> of the work-unit-specific data key <code>key</code> in the work unit <code>thread</code>.</p>
<p>Work-unit-specific values associated with a work-unit-specific data key are read and updated atomically.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_KEY</code> is returned if <code>key</code> is <code>ABT_KEY_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>work unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>work-unit-specific data key handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l02033">2033</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga177c58ca9094dc7feeb93521e30ff2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177c58ca9094dc7feeb93521e30ff2aa">&#9670;&nbsp;</a></span>ABT_thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the calling ULT to its parent ULT. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga177c58ca9094dc7feeb93521e30ff2aa" title="Yield the calling ULT to its parent ULT.">ABT_thread_yield()</a></code> yields the calling ULT and pushes the calling ULT to its associated pool. Its parent ULT will be resumed.</p>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><p class="startdd"><b>[Argobots 1.x]</b> This routine returns <code>ABT_SUCCESS</code> without any effect if a tasklet calls this routine.<br  />
 <b>[Argobots 2.0]</b> This routine returns <code>ABT_ERR_INV_THREAD</code> if a tasklet calls this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>A tasklet cannot achieve the purpose of this routine. This routine should return an error. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.x]</b> This routine returns <code>ABT_SUCCESS</code> without any effect if an external thread calls this routine.<br  />
 <b>[Argobots 2.0]</b> This routine returns <code>ABT_ERR_INV_XSTREAM</code> if an external thread calls this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>An external thread cannot achieve the purpose of this routine. This routine should return an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd><b>[Argobots 1.x]</b> This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.<br  />
<b>[Argobots 2.0]</b> This routine can be called in a ULT context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<b>[Argobots 2.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the caller is a tasklet.<br  />
<b>[Argobots 2.0]</b> <code>ABT_ERR_INV_XSTREAM</code> is returned if the caller is an external thread.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If the caller is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01121">1121</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="ga1fa419c69e734d2017e8238d438a216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa419c69e734d2017e8238d438a216a">&#9670;&nbsp;</a></span>ABT_thread_yield_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_thread_yield_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6d/group__ULT.html#ga186008e05c04170eed9ac74808619717">ABT_thread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the calling ULT to the specific ULT. </p>
<p><code><a class="el" href="../../d0/d6d/group__ULT.html#ga1fa419c69e734d2017e8238d438a216a" title="Yield the calling ULT to the specific ULT.">ABT_thread_yield_to()</a></code> yields the calling ULT and schedules the ULT <code>thread</code> that is in its associated pool. The calling ULT will be pushed to its associated pool.</p>
<dl class="section note"><dt>Note</dt><dd>This routine is experimental. The details of this function may be updated in the future.</dd></dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><p class="startdd"><b>[Argobots 1.x]</b> This routine returns <code>ABT_SUCCESS</code> without any effect if a tasklet calls this routine.<br  />
 <b>[Argobots 2.0]</b> This routine returns <code>ABT_ERR_INV_THREAD</code> if a tasklet calls this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>A tasklet cannot achieve the purpose of this routine. This routine should return an error. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.x]</b> This routine returns <code>ABT_SUCCESS</code> without any effect if an external thread calls this routine.<br  />
 <b>[Argobots 2.0]</b> This routine returns <code>ABT_ERR_INV_XSTREAM</code> if an external thread calls this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>An external thread cannot achieve the purpose of this routine. This routine should return an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd><b>[Argobots 1.x]</b> This routine can be called in any execution context. Argobots must be initialized. This routine may switch the context of the calling ULT.<br  />
<b>[Argobots 2.0]</b> This routine can be called in a ULT context. Argobots must be initialized. This routine may switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is <code>ABT_THREAD_NULL</code> or <code>ABT_TASK_NULL</code>.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is a tasklet.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if the caller is the work unit of the main scheduler.<br  />
<code>ABT_ERR_INV_THREAD</code> is returned if <code>thread</code> is the caller.<br  />
<code>ABT_ERR_POOL</code> is returned if a pool associated with <code>thread</code> does not support functions that are necessary for this routine.<br  />
<b>[Argobots 2.0]</b> <code>ABT_ERR_INV_THREAD</code> is returned if the caller is a tasklet.<br  />
<b>[Argobots 2.0]</b> <code>ABT_ERR_INV_XSTREAM</code> is returned if the caller is an external thread.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If the caller is accessed concurrently, the results are undefined.<br  />
If <code>thread</code> is accessed concurrently, the results are undefined.<br  />
If the pool associated with <code>thread</code> is not in <code>thread</code>, the results are undefined.<br  />
If <code>thread</code> is not ready, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>handle to the target thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/de7/thread_8c_source.html#l01009">1009</a> of file <a class="el" href="../../d3/de7/thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aabt_8h_html_aabf134f2165a5d15ea5bd063b982d8a6"><div class="ttname"><a href="../../d5/d7d/abt_8h.html#aabf134f2165a5d15ea5bd063b982d8a6">ABT_THREAD_NULL</a></div><div class="ttdeci">#define ABT_THREAD_NULL</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d7d/abt_8h_source.html#l01059">abt.h:1059</a></div></div>
<div class="ttc" id="aabt_8h_html_acedaaeb67b83967cc9129e0906f38e93"><div class="ttname"><a href="../../d5/d7d/abt_8h.html#acedaaeb67b83967cc9129e0906f38e93">ABT_TASK_NULL</a></div><div class="ttdeci">#define ABT_TASK_NULL</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d7d/abt_8h_source.html#l01061">abt.h:1061</a></div></div>
<div class="ttc" id="aabt_8h_html_a1839f64e5a2462a68ffd82ba94213582"><div class="ttname"><a href="../../d5/d7d/abt_8h.html#a1839f64e5a2462a68ffd82ba94213582">ABT_TRUE</a></div><div class="ttdeci">#define ABT_TRUE</div><div class="ttdoc">True constant for ABT_bool.</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d7d/abt_8h_source.html#l00745">abt.h:745</a></div></div>
<div class="ttc" id="aabt_8h_html_aedde437380ced4813c3c36d97e926a25"><div class="ttname"><a href="../../d5/d7d/abt_8h.html#aedde437380ced4813c3c36d97e926a25">ABT_FALSE</a></div><div class="ttdeci">#define ABT_FALSE</div><div class="ttdoc">False constant for ABT_bool.</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d7d/abt_8h_source.html#l00747">abt.h:747</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 5 2021 03:10:29 for ARGOBOTS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
