<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>ARGOBOTS: Pool</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ARGOBOTS
   &#160;<span id="projectnumber">140a356fc09a44696eb3487150e459266f9b5405</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Pool</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfc/structABT__pool__def.html">ABT_pool_def</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that defines a pool.  <a href="../../d4/dfc/structABT__pool__def.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6bbc8a95dbe08348262228f3355652b2"><td class="memItemLeft" align="right" valign="top">typedef struct ABT_pool_opaque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a></td></tr>
<tr class="memdesc:ga6bbc8a95dbe08348262228f3355652b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool handle type.  <a href="#ga6bbc8a95dbe08348262228f3355652b2">More...</a><br/></td></tr>
<tr class="separator:ga6bbc8a95dbe08348262228f3355652b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2554363a286799e1e0f4be8b442802"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
ABT_pool_config_opaque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a></td></tr>
<tr class="memdesc:ga4b2554363a286799e1e0f4be8b442802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool configuration handle type.  <a href="#ga4b2554363a286799e1e0f4be8b442802">More...</a><br/></td></tr>
<tr class="separator:ga4b2554363a286799e1e0f4be8b442802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e2f99de4456f4816000b4d1589bee6a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga3e2f99de4456f4816000b4d1589bee6a">ABT_pool_kind</a></td></tr>
<tr class="memdesc:ga3e2f99de4456f4816000b4d1589bee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined pool type.  <a href="#ga3e2f99de4456f4816000b4d1589bee6a">More...</a><br/></td></tr>
<tr class="separator:ga3e2f99de4456f4816000b4d1589bee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37f3c8382adf2e34fb1f02ae07d03c8"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaf37f3c8382adf2e34fb1f02ae07d03c8">ABT_pool_access</a></td></tr>
<tr class="memdesc:gaf37f3c8382adf2e34fb1f02ae07d03c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool access type.  <a href="#gaf37f3c8382adf2e34fb1f02ae07d03c8">More...</a><br/></td></tr>
<tr class="separator:gaf37f3c8382adf2e34fb1f02ae07d03c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3d9e73381c78389a50ef463732e672a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a> { <a class="el" href="../../d9/d52/group__POOL.html#gga3d9e73381c78389a50ef463732e672a1a9f3f606b821abf78ccefd65ae5ce494c">ABT_POOL_FIFO</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#gga3d9e73381c78389a50ef463732e672a1a0cb3dad152f9501d06400bd075c4dbd6">ABT_POOL_FIFO_WAIT</a>
 }</td></tr>
<tr class="memdesc:ga3d9e73381c78389a50ef463732e672a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined pool type.  <a href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">More...</a><br/></td></tr>
<tr class="separator:ga3d9e73381c78389a50ef463732e672a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33f04702fb8618eed4f6ece04041ecf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> { <br/>
&#160;&#160;<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa6b52ca5bbffb03291d493257a8fe5bed">ABT_POOL_ACCESS_PRIV</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa9385bbd5d15bee55652e14e7546a0425">ABT_POOL_ACCESS_SPSC</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfabb04cf57d6a62299db2783422069d1ef">ABT_POOL_ACCESS_MPSC</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa2d9b6671e37097bb153513c200a2ad46">ABT_POOL_ACCESS_SPMC</a>, 
<br/>
&#160;&#160;<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfaef5831d28ade4eb4b2a8e69a4c5bb39f">ABT_POOL_ACCESS_MPMC</a>
<br/>
 }</td></tr>
<tr class="memdesc:gad33f04702fb8618eed4f6ece04041ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool access type.  <a href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">More...</a><br/></td></tr>
<tr class="separator:gad33f04702fb8618eed4f6ece04041ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a000646ad0b5899ee47779d051758e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8">ABT_pool_create</a> (<a class="el" href="../../d4/dfc/structABT__pool__def.html">ABT_pool_def</a> *def, <a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a> config, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *newpool)</td></tr>
<tr class="memdesc:ga7a000646ad0b5899ee47779d051758e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pool.  <a href="#ga7a000646ad0b5899ee47779d051758e8">More...</a><br/></td></tr>
<tr class="separator:ga7a000646ad0b5899ee47779d051758e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae479c7d7ae2816d8a953ea307611b49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49">ABT_pool_create_basic</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a> kind, <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> access, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> automatic, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *newpool)</td></tr>
<tr class="memdesc:gaae479c7d7ae2816d8a953ea307611b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pool from a predefined type.  <a href="#gaae479c7d7ae2816d8a953ea307611b49">More...</a><br/></td></tr>
<tr class="separator:gaae479c7d7ae2816d8a953ea307611b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99295e7c312a3b0699b3f5c9ae4cfc60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60">ABT_pool_free</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *pool)</td></tr>
<tr class="memdesc:ga99295e7c312a3b0699b3f5c9ae4cfc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a pool.  <a href="#ga99295e7c312a3b0699b3f5c9ae4cfc60">More...</a><br/></td></tr>
<tr class="separator:ga99295e7c312a3b0699b3f5c9ae4cfc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6089256f32498ee058e6df9478f95574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga6089256f32498ee058e6df9478f95574">ABT_pool_get_access</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> *access)</td></tr>
<tr class="memdesc:ga6089256f32498ee058e6df9478f95574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an access type of a pool.  <a href="#ga6089256f32498ee058e6df9478f95574">More...</a><br/></td></tr>
<tr class="separator:ga6089256f32498ee058e6df9478f95574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89312324e2c5a199992323035d9bb7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga89312324e2c5a199992323035d9bb7c2">ABT_pool_get_total_size</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, size_t *size)</td></tr>
<tr class="memdesc:ga89312324e2c5a199992323035d9bb7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of a pool.  <a href="#ga89312324e2c5a199992323035d9bb7c2">More...</a><br/></td></tr>
<tr class="separator:ga89312324e2c5a199992323035d9bb7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe8ef10c4d7fe1c7f7263fdc56fa58e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaafe8ef10c4d7fe1c7f7263fdc56fa58e">ABT_pool_get_size</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, size_t *size)</td></tr>
<tr class="memdesc:gaafe8ef10c4d7fe1c7f7263fdc56fa58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a pool.  <a href="#gaafe8ef10c4d7fe1c7f7263fdc56fa58e">More...</a><br/></td></tr>
<tr class="separator:gaafe8ef10c4d7fe1c7f7263fdc56fa58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50138fd611a69d657d3314cd606c68f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6">ABT_pool_pop</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *p_unit)</td></tr>
<tr class="memdesc:ga50138fd611a69d657d3314cd606c68f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a work unit from a pool.  <a href="#ga50138fd611a69d657d3314cd606c68f6">More...</a><br/></td></tr>
<tr class="separator:ga50138fd611a69d657d3314cd606c68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22802d586052a8562abc07f779b5302"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302">ABT_pool_pop_wait</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *p_unit, double time_secs)</td></tr>
<tr class="memdesc:gaf22802d586052a8562abc07f779b5302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a unit from a pool with wait.  <a href="#gaf22802d586052a8562abc07f779b5302">More...</a><br/></td></tr>
<tr class="separator:gaf22802d586052a8562abc07f779b5302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2352e41d6926b40fdabb97a72a90c144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga2352e41d6926b40fdabb97a72a90c144">ABT_pool_pop_timedwait</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *p_unit, double abstime_secs)</td></tr>
<tr class="memdesc:ga2352e41d6926b40fdabb97a72a90c144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a unit from a pool with timed wait.  <a href="#ga2352e41d6926b40fdabb97a72a90c144">More...</a><br/></td></tr>
<tr class="separator:ga2352e41d6926b40fdabb97a72a90c144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f37f5da3f8c2d8a0eb349063e31f3fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa">ABT_pool_push</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> unit)</td></tr>
<tr class="memdesc:ga8f37f5da3f8c2d8a0eb349063e31f3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a unit to a pool.  <a href="#ga8f37f5da3f8c2d8a0eb349063e31f3fa">More...</a><br/></td></tr>
<tr class="separator:ga8f37f5da3f8c2d8a0eb349063e31f3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7747df606be0704dd7894ac79dd56b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga2d7747df606be0704dd7894ac79dd56b">ABT_pool_remove</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> unit)</td></tr>
<tr class="memdesc:ga2d7747df606be0704dd7894ac79dd56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specified work unit from a pool.  <a href="#ga2d7747df606be0704dd7894ac79dd56b">More...</a><br/></td></tr>
<tr class="separator:ga2d7747df606be0704dd7894ac79dd56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1c11ccced444023a1fab17c148a5ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga4e1c11ccced444023a1fab17c148a5ca">ABT_pool_print_all</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void *arg, void(*print_fn)(void *, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>))</td></tr>
<tr class="memdesc:ga4e1c11ccced444023a1fab17c148a5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a print function to every work unit in a pool using a user-defined function.  <a href="#ga4e1c11ccced444023a1fab17c148a5ca">More...</a><br/></td></tr>
<tr class="separator:ga4e1c11ccced444023a1fab17c148a5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4cb8502f813229d2fbb5e0961ffdf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3">ABT_pool_set_data</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void *<a class="el" href="../../df/dea/structdata.html">data</a>)</td></tr>
<tr class="memdesc:gaae4cb8502f813229d2fbb5e0961ffdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user data in a pool.  <a href="#gaae4cb8502f813229d2fbb5e0961ffdf3">More...</a><br/></td></tr>
<tr class="separator:gaae4cb8502f813229d2fbb5e0961ffdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e9bbf2126b7c2b951068bafbd47fde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gac5e9bbf2126b7c2b951068bafbd47fde">ABT_pool_get_data</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void **<a class="el" href="../../df/dea/structdata.html">data</a>)</td></tr>
<tr class="memdesc:gac5e9bbf2126b7c2b951068bafbd47fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve user data from a pool.  <a href="#gac5e9bbf2126b7c2b951068bafbd47fde">More...</a><br/></td></tr>
<tr class="separator:gac5e9bbf2126b7c2b951068bafbd47fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398216ecd06e4ae64396c2565ecb4efa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga398216ecd06e4ae64396c2565ecb4efa">ABT_pool_add_sched</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../d0/d83/group__SCHED.html#gadf0a564b506bb4a288f49cbfd3116025">ABT_sched</a> sched)</td></tr>
<tr class="memdesc:ga398216ecd06e4ae64396c2565ecb4efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new work unit associated with a scheduler and push it to a pool.  <a href="#ga398216ecd06e4ae64396c2565ecb4efa">More...</a><br/></td></tr>
<tr class="separator:ga398216ecd06e4ae64396c2565ecb4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b9d5f542cb31852aaa4d7079350e74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gae3b9d5f542cb31852aaa4d7079350e74">ABT_pool_get_id</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, int *id)</td></tr>
<tr class="memdesc:gae3b9d5f542cb31852aaa4d7079350e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of a pool.  <a href="#gae3b9d5f542cb31852aaa4d7079350e74">More...</a><br/></td></tr>
<tr class="separator:gae3b9d5f542cb31852aaa4d7079350e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group is for Pool. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga6bbc8a95dbe08348262228f3355652b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ABT_pool_opaque* <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool handle type. </p>
<p>A NULL handle of this type is <code>ABT_POOL_NULL</code>. </p>

<p>Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00828">828</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf37f3c8382adf2e34fb1f02ae07d03c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool access type. </p>

<p>Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00845">845</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b2554363a286799e1e0f4be8b442802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ABT_pool_config_opaque* <a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool configuration handle type. </p>
<p>A NULL handle of this type is <code>ABT_POOL_CONFIG_NULL</code>. </p>

<p>Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00835">835</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e2f99de4456f4816000b4d1589bee6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a> <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined pool type. </p>

<p>Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00840">840</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gad33f04702fb8618eed4f6ece04041ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool access type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggad33f04702fb8618eed4f6ece04041ecfa6b52ca5bbffb03291d493257a8fe5bed"></a>ABT_POOL_ACCESS_PRIV</em>&nbsp;</td><td class="fielddoc">
<p>The created pool may be pushed and popped by only one execution stream in the lifetime of the pool. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggad33f04702fb8618eed4f6ece04041ecfa9385bbd5d15bee55652e14e7546a0425"></a>ABT_POOL_ACCESS_SPSC</em>&nbsp;</td><td class="fielddoc">
<p>The created pool may be pushed by only one execution stream and popped by only one execution stream in the lifetime of the pool. The two execution streams can be different. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggad33f04702fb8618eed4f6ece04041ecfabb04cf57d6a62299db2783422069d1ef"></a>ABT_POOL_ACCESS_MPSC</em>&nbsp;</td><td class="fielddoc">
<p>The created pool may be popped by only one execution stream in the lifetime of the pool. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggad33f04702fb8618eed4f6ece04041ecfa2d9b6671e37097bb153513c200a2ad46"></a>ABT_POOL_ACCESS_SPMC</em>&nbsp;</td><td class="fielddoc">
<p>The created pool may be pushed by only one execution stream in the lifetime of the pool. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggad33f04702fb8618eed4f6ece04041ecfaef5831d28ade4eb4b2a8e69a4c5bb39f"></a>ABT_POOL_ACCESS_MPMC</em>&nbsp;</td><td class="fielddoc">
<p>No restriction regarding a caller of pushing and popping operations. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00514">514</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d9e73381c78389a50ef463732e672a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined pool type. </p>
<p>Predefined pools provide all the pool functions that are defined in <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool. ">ABT_pool_def</a></code> unless otherwise noted. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3d9e73381c78389a50ef463732e672a1a9f3f606b821abf78ccefd65ae5ce494c"></a>ABT_POOL_FIFO</em>&nbsp;</td><td class="fielddoc">
<p>FIFO pool. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3d9e73381c78389a50ef463732e672a1a0cb3dad152f9501d06400bd075c4dbd6"></a>ABT_POOL_FIFO_WAIT</em>&nbsp;</td><td class="fielddoc">
<p>FIFO pool with a waiting ability. If a caller's pop operation fails, either an execution stream running the caller or a calling external thread will suspend for a while. This can reduce CPU utilization when a pool is empty, but it increases an overhead of each pool operation.</p>
<p>If the user does not know how <code>ABT_POOL_FIFO_WAIT</code> works, <code>ABT_POOL_FIFO</code> is recommended. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00496">496</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga398216ecd06e4ae64396c2565ecb4efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_add_sched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d83/group__SCHED.html#gadf0a564b506bb4a288f49cbfd3116025">ABT_sched</a>&#160;</td>
          <td class="paramname"><em>sched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new work unit associated with a scheduler and push it to a pool. </p>
<p><a class="el" href="../../d9/d52/group__POOL.html#ga398216ecd06e4ae64396c2565ecb4efa" title="Create a new work unit associated with a scheduler and push it to a pool. ">ABT_pool_add_sched()</a> creates a work unit that works as a scheduler <code>sched</code> and pushes the newly created work unit to <code>pool</code>. See <code><a class="el" href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa" title="Push a unit to a pool. ">ABT_pool_push()</a></code> for the push operation. The created work unit is automatically freed when it finishes its scheduling function.</p>
<p>While the created work unit is using <code>sched</code>, the user may not free <code>sched</code>. Associating <code>sched</code> with more than one work unit causes undefined behavior.</p>
<p><code>sched</code> should have been created by <code><a class="el" href="../../d0/d83/group__SCHED.html#gaf6e505eaab2fe977bbaddb5b19c6b413" title="Create a new scheduler with a scheduler definition. ">ABT_sched_create()</a></code> or <code><a class="el" href="../../d0/d83/group__SCHED.html#gac3ea78b200ae62bf24deecf385a33f7b" title="Create a new scheduler with a predefined scheduler type. ">ABT_sched_create_basic()</a></code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>ABT_ERR_INV_SCHED</code> is returned if this routine finds <code>sched</code> is already used. <b>[Argobots 2.0]</b> The results are undefined if <code>sched</code> is already used. <dl class="section user">
<dt>Rationale</dt>
<dd>The current mechanism that checks if a scheduler is used is premature since this is not maintained atomically. From Argobots 2.0, it becomes the user's responsibility to guarantee that <code>sched</code> is not used. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned. If <code>sched</code> is <code>ABT_SCHED_NULL</code>, <code>ABT_ERR_INV_SCHED</code> is returned. If an error related to memory occurs, <code>ABT_ERR_MEM</code> is returned. If an error related to system calls occurs, <code>ABT_ERR_SYS</code> is returned. <b>[Argobots 1.x]</b> If <code>sched</code> is being used, <code>ABT_ERR_INV_SCHED</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. <b>[Argobots 2.0]</b> If <code>sched</code> is being used, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sched</td><td>scheduler handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00784">784</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a000646ad0b5899ee47779d051758e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dfc/structABT__pool__def.html">ABT_pool_def</a> *&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>newpool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code> creates a new pool, given by the pool definition (<code>def</code>) and a pool configuration (<code>config</code>), and returns its handle through <code>newpool</code>. If <code>p_init</code> is not <code>NULL</code>, this routine calls <code>p_init()</code> with <code>newpool</code> as the first argument and <code>config</code> as the second argument. This routine returns an error returned by <code>p_init()</code> if <code>p_init()</code> does not return <code>ABT_SUCCESS</code>.</p>
<p>The user can pass <code>ABT_POOL_CONFIG_NULL</code> as <code>config</code>. The configuration is passed as the parameter of the initialization function of the pool.</p>
<p><code>def</code> must define all the non-optional functions. See <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool. ">ABT_pool_def</a></code> for details.</p>
<p>The caller of each pool function is undefined, so a program that relies on the caller of pool functions is non-conforming.</p>
<dl class="section note"><dt>Note</dt><dd>Specifically, any explicit or implicit context-switching operation in a pool function may cause undefined behavior.</dd></dl>
<p>This routine copies <code>def</code> and <code>config</code>, so the user can free <code>def</code> and <code>config</code> after this routine returns.</p>
<p>The created pool is not automatically freed, so <code>newpool</code> must be freed by <code><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60" title="Free a pool. ">ABT_pool_free()</a></code> after its use unless <code>newpool</code> is associated with the main scheduler of the primary execution stream.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="../../d4/d00/group__ENV.html#ga70dc165656888def26f8cb6c047a6289" title="Finalize the Argobots execution environment. ">ABT_finalize()</a></code> frees the primary execution stream, its main scheduler, and pools associated with the main scheduler.</dd></dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>newpool</code> is set to <code>ABT_POOL_NULL</code> if an error occurs. <b>[Argobots 2.0]</b> <code>newpool</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect if the routine returns an error (as possible). Argobots 2.0 does not update a returned value when the routine throws an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>p_init()</code> does not return <code>ABT_SUCCESS</code>, the error returned by <code>p_init()</code> is returned. If an error related to memory occurs, <code>ABT_ERR_MEM</code> is returned. If an error related to system calls occurs, <code>ABT_ERR_SYS</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>def</code> is <code>NULL</code>, the results are undefined. If any non-optional pool function of <code>def</code> is <code>NULL</code>, the results are undefined. If <code>newpool</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>pool definition required for pool creation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>pool configuration for pool creation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newpool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00072">72</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaae479c7d7ae2816d8a953ea307611b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_create_basic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a>&#160;</td>
          <td class="paramname"><em>automatic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>newpool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pool from a predefined type. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code> creates a new pool, given by the pool type <code>kind</code>, the access type <code>access</code>, and the automatic flag <code>automatic</code>, and returns its handle through <code>newpool</code>.</p>
<p><code>kind</code> specifies the implementation of <code>newpool</code>. See <code><a class="el" href="../../d9/d52/group__POOL.html#ga3e2f99de4456f4816000b4d1589bee6a" title="Predefined pool type. ">ABT_pool_kind</a></code> for details of predefined pools.</p>
<p><code>access</code> hints at the usage of the created pool. Argobots may choose an optimized implementation for a pool with a more restricted access type (<code><a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa6b52ca5bbffb03291d493257a8fe5bed">ABT_POOL_ACCESS_PRIV</a></code> is the most strict access type). See <code><a class="el" href="../../d9/d52/group__POOL.html#gaf37f3c8382adf2e34fb1f02ae07d03c8" title="Pool access type. ">ABT_pool_access</a></code> for details.</p>
<p>If <code>automatic</code> is <code>ABT_FALSE</code>, <code>newpool</code> is not automatically freed, so <code>newpool</code> must be freed by <code><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60" title="Free a pool. ">ABT_pool_free()</a></code> after its use unless <code>newpool</code> is associated with the main scheduler of the primary execution stream.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="../../d4/d00/group__ENV.html#ga70dc165656888def26f8cb6c047a6289" title="Finalize the Argobots execution environment. ">ABT_finalize()</a></code> frees the primary execution stream, its main scheduler, and pools associated with the main scheduler.</dd></dl>
<p>If <code>automatic</code> is <code>ABT_TRUE</code>, <code>newpool</code> is automatically freed when all the schedulers associated with <code>newpool</code> are freed. If the user does not associate <code>newpool</code> with a scheduler, the user needs to manually free <code>newpool</code> regardless of <code>automatic</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The Argobots runtime respects an access type of a pool and returns an error if possible if a pool access violation happens regarding an access type of a pool. <b>[Argobots 1.1]</b> The Argobots runtime does not check an access type of a pool. If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>This access type was used for access violation error check. This check will be removed in Argobots 1.1 since correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>newpool</code> is set to <code>ABT_POOL_NULL</code> if an error occurs. <b>[Argobots 2.0]</b> <code>newpool</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect if the routine returns an error (as possible). Argobots 2.0 does not update a returned value when the routine throws an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>kind</code> is not a valid pool kind, <code>ABT_ERR_INV_POOL_KIND</code> is returned. If <code>access</code> is not a valid pool access type, <code>ABT_ERR_INV_POOL_ACCESS</code> is returned. If an error related to memory occurs, <code>ABT_ERR_MEM</code> is returned. If an error related to system calls occurs, <code>ABT_ERR_SYS</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If automatic is neither <code>ABT_TRUE</code> nor <code>ABT_FALSE</code>, the results are undefined. If <code>newpool</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>type of the predefined pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">access</td><td>access type of the predefined pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">automatic</td><td><code>ABT_TRUE</code> if the pool should be automatically freed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newpool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00166">166</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga99295e7c312a3b0699b3f5c9ae4cfc60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60" title="Free a pool. ">ABT_pool_free()</a></code> frees the resource used for the pool <code>pool</code> and sets <code>pool</code> to <code>ABT_POOL_NULL</code>. If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code> and <code>p_free</code> is not <code>NULL</code>, this routine calls <code>p_free()</code> with <code>pool</code> as the argument. The return value of <code>p_free()</code> is ignored. Afterward, this routine deallocates the resource used for <code>pool</code> and sets <code>pool</code> to <code>ABT_POOL_NULL</code>.</p>
<p><code>pool</code> must be empty and no work unit may be associated with <code>pool</code>.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> points to <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>pool</code> is <code>NULL</code>, the results are undefined. If <code>pool</code> is not empty, the results are undefined. If any work unit is still associated with <code>pool</code>, the results are undefined. If <code>pool</code> is accessed after calling this routine, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00210">210</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6089256f32498ee058e6df9478f95574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> *&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an access type of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga6089256f32498ee058e6df9478f95574" title="Get an access type of a pool. ">ABT_pool_get_access()</a></code> returns the access type of the pool <code>pool</code> through <code>access</code>.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>access</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">access</td><td>access type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00244">244</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac5e9bbf2126b7c2b951068bafbd47fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve user data from a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3" title="Set user data in a pool. ">ABT_pool_set_data()</a></code> returns user data in the pool <code>pool</code> through <code>data</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The specific data of the newly created pool is <code>NULL</code>.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>data</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>user data in <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00732">732</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae3b9d5f542cb31852aaa4d7079350e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gae3b9d5f542cb31852aaa4d7079350e74" title="Get ID of a pool. ">ABT_pool_get_id()</a></code> returns the ID of the pool <code>pool</code> through <code>id</code>.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>id</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>pool ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00830">830</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaafe8ef10c4d7fe1c7f7263fdc56fa58e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaafe8ef10c4d7fe1c7f7263fdc56fa58e" title="Get the size of a pool. ">ABT_pool_get_size()</a></code> returns the size of the pool <code>pool</code> through <code>size</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to a value returned by <code>p_get_size()</code> called with <code>pool</code> as its argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to the number of work units in <code>pool</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>size</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>size of <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00333">333</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga89312324e2c5a199992323035d9bb7c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_total_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga89312324e2c5a199992323035d9bb7c2" title="Get the total size of a pool. ">ABT_pool_get_total_size()</a></code> returns the total size of the pool <code>pool</code> through <code>size</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to the sum of a value returned by <code>p_get_size()</code> called with <code>pool</code> as its argument and the number of blocking work units that are associated with <code>pool</code>.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to the sum of the number of work units including in <code>pool</code> and the number of blocking work units associated with <code>pool</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>size</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>total size of <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00290">290</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga50138fd611a69d657d3314cd606c68f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *&#160;</td>
          <td class="paramname"><em>p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a work unit from a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6" title="Pop a work unit from a pool. ">ABT_pool_pop()</a></code> pops a work unit from the pool <code>pool</code> and sets it to <code>p_unit</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>p_unit</code> to a value returned by <code>p_pop()</code> called with <code>pool</code> as its argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine tries to pop a work unit from <code>pool</code>. If this routine successfully pops a work unit, this routine sets <code>p_unit</code> to the obtained handle of <code>ABT_unit</code>. Otherwise, this routine sets <code>ABT_UNIT_NULL</code> to <code>p_unit</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> If an external thread calls this routine, <code>ABT_ERR_INV_XSTREAM</code> is returned. <b>[Argobots 1.1]</b> An external thread may call this routine. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 narrows the type of the caller without any reason. Argobots 1.1 fixes it. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>p_unit</code> is set to <code>ABT_UNIT_NULL</code> if an error occurs. <b>[Argobots 2.0]</b> <code>p_unit</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect if the routine returns an error (as possible). Argobots 2.0 does not update a returned value when the routine throws an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd><b>[Argobots 1.x]</b> This routine can be called in either a ULT context or a tasklet context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.<br/>
<b>[Argobots 2.0]</b> This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>p_unit</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_unit</td><td>unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00387">387</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2352e41d6926b40fdabb97a72a90c144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_pop_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *&#160;</td>
          <td class="paramname"><em>p_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstime_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a unit from a pool with timed wait. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga2352e41d6926b40fdabb97a72a90c144" title="Pop a unit from a pool with timed wait. ">ABT_pool_pop_timedwait()</a></code> pops a work unit from the pool <code>pool</code> and sets it to <code>p_unit</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>p_unit</code> to a value returned by <code>p_pop_timedwait()</code> called with <code>pool</code> as its first argument and <code>abstime_sec</code> as the second argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine tries to pop a work unit from <code>pool</code>. If <code>pool</code> is empty, an underlying execution stream or an external thread that calls this routine is blocked on <code>pool</code> until the current time exceeds <code>abstime_secs</code>. If this routine successfully pops a work unit, this routine sets <code>p_unit</code> to the obtained handle of <code>ABT_unit</code>. Otherwise, this routine sets <code>ABT_UNIT_NULL</code> to <code>p_unit</code>.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>abstime_secs</code> can be calculated by adding an offset time to a value returned by <code><a class="el" href="../../d0/dde/group__TIMER.html#ga872b14356c27d22d4f18c85303a37608" title="Get elapsed wall clock time. ">ABT_get_wtime()</a></code>.</dd></dl>
<p>This routine is deprecated. The user should use <code><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302" title="Pop a unit from a pool with wait. ">ABT_pool_pop_wait()</a></code> instead.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> If an external thread calls this routine, <code>ABT_ERR_INV_XSTREAM</code> is returned. <b>[Argobots 1.1]</b> An external thread may call this routine. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 narrows the type of the caller without any reason. Argobots 1.1 fixes it. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>p_unit</code> is set to <code>ABT_UNIT_NULL</code> if an error occurs. <b>[Argobots 2.0]</b> <code>p_unit</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect if the routine returns an error (as possible). Argobots 2.0 does not update a returned value when the routine throws an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned. If <code>pool</code> does not support <code>p_pop_timedwait()</code>, <code>ABT_ERR_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>p_unit</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_unit</td><td>unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abstime_secs</td><td>absolute time for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00511">511</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf22802d586052a8562abc07f779b5302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_pop_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *&#160;</td>
          <td class="paramname"><em>p_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a unit from a pool with wait. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302" title="Pop a unit from a pool with wait. ">ABT_pool_pop_wait()</a></code> pops a work unit from the pool <code>pool</code> and sets it to <code>p_unit</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>p_unit</code> to a value returned by <code>p_pop_wait()</code> called with <code>pool</code> as its first argument and <code>time_sec</code> as the second argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine tries to pop a work unit from <code>pool</code>. If <code>pool</code> is empty, an underlying execution stream or an external thread that calls this routine is blocked on <code>pool</code> for <code>time_sec</code> seconds. If this routine successfully pops a work unit, this routine sets <code>p_unit</code> to the obtained handle of <code>ABT_unit</code>. Otherwise, this routine sets <code>p_unit</code> to <code>ABT_UNIT_NULL</code>.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In most cases, <code><a class="el" href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6" title="Pop a work unit from a pool. ">ABT_pool_pop()</a></code> is more efficient. <code><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302" title="Pop a unit from a pool with wait. ">ABT_pool_pop_wait()</a></code> would be useful in cases where the user wants to make execution streams sleep when <code>pool</code> is empty.</dd></dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><p class="startdd"><b>[Argobots 1.x]</b> <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool. ">ABT_pool_def</a></code> does not define <code>p_pop_wait</code>. <b>[Argobots 2.0]</b> <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool. ">ABT_pool_def</a></code> defines <code>p_pop_wait</code>. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>To maintain the ABI compatibility, <code>p_pop_wait</code> is excluded from <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool. ">ABT_pool_def</a></code>. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.x]</b> <code>p_unit</code> is set to <code>ABT_UNIT_NULL</code> if an error occurs. <b>[Argobots 2.0]</b> <code>p_unit</code> is not updated if an error occurs. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect if the routine returns an error (as possible). Argobots 2.0 does not update a returned value when the routine throws an error. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned. If <code>pool</code> does not support <code>p_pop_wait()</code>, <code>ABT_ERR_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>p_unit</code> is <code>NULL</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_unit</td><td>unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_secs</td><td>duration of waiting time (seconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00445">445</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e1c11ccced444023a1fab17c148a5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_print_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>)&#160;</td>
          <td class="paramname"><em>print_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a print function to every work unit in a pool using a user-defined function. </p>
<p><code><a class="el" href="../../d5/d7d/abt_8h.html#a77a4457600d17f0ef3ea6ab58c9622e6">ABT_pool_print_all()</a></code> calls <code>print_fn()</code> for every work unit in the pool <code>pool</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine calls <code>p_pop_print()</code> with <code>pool</code> as its first argument, <code>arg</code> as the second argument, and <code>print_fn</code> as the third argument The return value of <code>p_pop_print()</code> is ignored.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine calls <code>print_fn()</code> for every work unit in <code>pool</code>. <code>print_fn()</code> is called with <code>arg</code> as its first argument and the handle of the work unit as the second argument.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>As the name of the argument implies, <code>print_fn()</code> may not have any side effect; <code><a class="el" href="../../d5/d7d/abt_8h.html#a77a4457600d17f0ef3ea6ab58c9622e6">ABT_pool_print_all()</a></code> is for debugging and profiling. For example, changing the state of <code>ABT_unit</code> in <code>print_fn()</code> is forbidden.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned. If <code>pool</code> does not support <code>p_print_all()</code>, <code>ABT_ERR_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>print_fn</code> is <code>NULL</code>, the results are undefined. If the internal state of the Argobots is changed in <code>print_fn()</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument passed to <code>print_fn</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print_fn</td><td>user-defined print function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00666">666</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f37f5da3f8c2d8a0eb349063e31f3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a unit to a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa" title="Push a unit to a pool. ">ABT_pool_push()</a></code> pushes a work unit <code>unit</code> to the pool <code>pool</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine calls <code>p_push()</code> with <code>pool</code> as its first argument and <code>unit</code> as the second argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine pushes a work unit <code>unit</code> to <code>pool</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> <code>ABT_ERR_UNIT</code> is returned if <code>unit</code> is <code>ABT_UNIT_NULL</code>. <b>[Argobots 1.1]</b> <code>ABT_ERR_INV_UNIT</code> is returned if <code>unit</code> is <code>ABT_UNIT_NULL</code>. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 returned an error code which is obviously wrong. Argobots 1.1 fixes the error code for consistent behavior with the other Argobots routines. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned. If <code>unit</code> is <code>ABT_UNIT_NULL</code>, <code>ABT_ERR_INV_UNIT</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>unit</code> is not associated with <code>pool</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit</td><td>unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00560">560</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d7747df606be0704dd7894ac79dd56b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a specified work unit from a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga2d7747df606be0704dd7894ac79dd56b" title="Remove a specified work unit from a pool. ">ABT_pool_remove()</a></code> removes a work unit <code>unit</code> from the pool <code>pool</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool. ">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine calls <code>p_remove()</code> with <code>pool</code> as its first argument and <code>unit</code> as the second argument. The return value of <code>p_remove()</code> is ignored.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type. ">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine removes a work unit <code>unit</code> from the pool <code>pool</code> and returns <code>ABT_SUCCESS</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned. <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> If an external thread calls this routine, <code>ABT_ERR_INV_XSTREAM</code> is returned. <b>[Argobots 1.1]</b> An external thread may call this routine. </p>
<dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 narrows the type of the caller without any reason. Argobots 1.1 fixes it. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned. If <code>unit</code> is <code>ABT_UNIT_NULL</code>, <code>ABT_ERR_INV_UNIT</code> is returned. If <code>pool</code> does not support <code>p_remove()</code>, <code>ABT_ERR_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>unit</code> is not in <code>pool</code>, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit</td><td>unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00612">612</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaae4cb8502f813229d2fbb5e0961ffdf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_set_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set user data in a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3" title="Set user data in a pool. ">ABT_pool_set_data()</a></code> sets user data of the pool <code>pool</code> to <code>data</code>. The old value is overwritten.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not perform context switching the calling ULT unless any user-defined function that is involved in this routine performs context switching.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>If this routine succeeds, <code>ABT_SUCCESS</code> is returned. If <code>pool</code> is <code>ABT_POOL_NULL</code>, <code>ABT_ERR_INV_POOL</code> is returned.</dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined. If <code>pool</code> is accessed concurrently, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>user data in <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p>Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00699">699</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 9 2021 03:09:56 for ARGOBOTS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
