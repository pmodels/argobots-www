<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARGOBOTS: Pool</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ARGOBOTS
   &#160;<span id="projectnumber">f816757cfdc8e5fef84abc0c0bf0a654684af46a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Pool</div>  </div>
</div><!--header-->
<div class="contents">

<p>This group is for Pool.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfc/structABT__pool__def.html">ABT_pool_def</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that defines a pool.  <a href="../../d4/dfc/structABT__pool__def.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6bbc8a95dbe08348262228f3355652b2"><td class="memItemLeft" align="right" valign="top">typedef struct ABT_pool_opaque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a></td></tr>
<tr class="memdesc:ga6bbc8a95dbe08348262228f3355652b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool handle type.  <a href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">More...</a><br /></td></tr>
<tr class="separator:ga6bbc8a95dbe08348262228f3355652b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2554363a286799e1e0f4be8b442802"><td class="memItemLeft" align="right" valign="top">typedef struct ABT_pool_config_opaque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a></td></tr>
<tr class="memdesc:ga4b2554363a286799e1e0f4be8b442802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool configuration handle type.  <a href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">More...</a><br /></td></tr>
<tr class="separator:ga4b2554363a286799e1e0f4be8b442802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e2f99de4456f4816000b4d1589bee6a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga3e2f99de4456f4816000b4d1589bee6a">ABT_pool_kind</a></td></tr>
<tr class="memdesc:ga3e2f99de4456f4816000b4d1589bee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined pool type.  <a href="../../d9/d52/group__POOL.html#ga3e2f99de4456f4816000b4d1589bee6a">More...</a><br /></td></tr>
<tr class="separator:ga3e2f99de4456f4816000b4d1589bee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37f3c8382adf2e34fb1f02ae07d03c8"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaf37f3c8382adf2e34fb1f02ae07d03c8">ABT_pool_access</a></td></tr>
<tr class="memdesc:gaf37f3c8382adf2e34fb1f02ae07d03c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool access type.  <a href="../../d9/d52/group__POOL.html#gaf37f3c8382adf2e34fb1f02ae07d03c8">More...</a><br /></td></tr>
<tr class="separator:gaf37f3c8382adf2e34fb1f02ae07d03c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3d9e73381c78389a50ef463732e672a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a> { <a class="el" href="../../d9/d52/group__POOL.html#gga3d9e73381c78389a50ef463732e672a1a9f3f606b821abf78ccefd65ae5ce494c">ABT_POOL_FIFO</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#gga3d9e73381c78389a50ef463732e672a1a0cb3dad152f9501d06400bd075c4dbd6">ABT_POOL_FIFO_WAIT</a>
 }</td></tr>
<tr class="memdesc:ga3d9e73381c78389a50ef463732e672a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined pool type.  <a href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">More...</a><br /></td></tr>
<tr class="separator:ga3d9e73381c78389a50ef463732e672a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33f04702fb8618eed4f6ece04041ecf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> { <br />
&#160;&#160;<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa6b52ca5bbffb03291d493257a8fe5bed">ABT_POOL_ACCESS_PRIV</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa9385bbd5d15bee55652e14e7546a0425">ABT_POOL_ACCESS_SPSC</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfabb04cf57d6a62299db2783422069d1ef">ABT_POOL_ACCESS_MPSC</a>, 
<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa2d9b6671e37097bb153513c200a2ad46">ABT_POOL_ACCESS_SPMC</a>, 
<br />
&#160;&#160;<a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfaef5831d28ade4eb4b2a8e69a4c5bb39f">ABT_POOL_ACCESS_MPMC</a>
<br />
 }</td></tr>
<tr class="memdesc:gad33f04702fb8618eed4f6ece04041ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool access type.  <a href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">More...</a><br /></td></tr>
<tr class="separator:gad33f04702fb8618eed4f6ece04041ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a000646ad0b5899ee47779d051758e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8">ABT_pool_create</a> (<a class="el" href="../../d4/dfc/structABT__pool__def.html">ABT_pool_def</a> *def, <a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a> config, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *newpool)</td></tr>
<tr class="memdesc:ga7a000646ad0b5899ee47779d051758e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pool.  <a href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8">More...</a><br /></td></tr>
<tr class="separator:ga7a000646ad0b5899ee47779d051758e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae479c7d7ae2816d8a953ea307611b49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49">ABT_pool_create_basic</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a> kind, <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> access, <a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a> automatic, <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *newpool)</td></tr>
<tr class="memdesc:gaae479c7d7ae2816d8a953ea307611b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pool from a predefined type.  <a href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49">More...</a><br /></td></tr>
<tr class="separator:gaae479c7d7ae2816d8a953ea307611b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99295e7c312a3b0699b3f5c9ae4cfc60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60">ABT_pool_free</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *pool)</td></tr>
<tr class="memdesc:ga99295e7c312a3b0699b3f5c9ae4cfc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a pool.  <a href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60">More...</a><br /></td></tr>
<tr class="separator:ga99295e7c312a3b0699b3f5c9ae4cfc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6089256f32498ee058e6df9478f95574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga6089256f32498ee058e6df9478f95574">ABT_pool_get_access</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> *access)</td></tr>
<tr class="memdesc:ga6089256f32498ee058e6df9478f95574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an access type of a pool.  <a href="../../d9/d52/group__POOL.html#ga6089256f32498ee058e6df9478f95574">More...</a><br /></td></tr>
<tr class="separator:ga6089256f32498ee058e6df9478f95574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89312324e2c5a199992323035d9bb7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga89312324e2c5a199992323035d9bb7c2">ABT_pool_get_total_size</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, size_t *size)</td></tr>
<tr class="memdesc:ga89312324e2c5a199992323035d9bb7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of a pool.  <a href="../../d9/d52/group__POOL.html#ga89312324e2c5a199992323035d9bb7c2">More...</a><br /></td></tr>
<tr class="separator:ga89312324e2c5a199992323035d9bb7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe8ef10c4d7fe1c7f7263fdc56fa58e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaafe8ef10c4d7fe1c7f7263fdc56fa58e">ABT_pool_get_size</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, size_t *size)</td></tr>
<tr class="memdesc:gaafe8ef10c4d7fe1c7f7263fdc56fa58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a pool.  <a href="../../d9/d52/group__POOL.html#gaafe8ef10c4d7fe1c7f7263fdc56fa58e">More...</a><br /></td></tr>
<tr class="separator:gaafe8ef10c4d7fe1c7f7263fdc56fa58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50138fd611a69d657d3314cd606c68f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6">ABT_pool_pop</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *p_unit)</td></tr>
<tr class="memdesc:ga50138fd611a69d657d3314cd606c68f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a work unit from a pool.  <a href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6">More...</a><br /></td></tr>
<tr class="separator:ga50138fd611a69d657d3314cd606c68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22802d586052a8562abc07f779b5302"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302">ABT_pool_pop_wait</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *p_unit, double time_secs)</td></tr>
<tr class="memdesc:gaf22802d586052a8562abc07f779b5302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a unit from a pool with wait.  <a href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302">More...</a><br /></td></tr>
<tr class="separator:gaf22802d586052a8562abc07f779b5302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2352e41d6926b40fdabb97a72a90c144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga2352e41d6926b40fdabb97a72a90c144">ABT_pool_pop_timedwait</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *p_unit, double abstime_secs)</td></tr>
<tr class="memdesc:ga2352e41d6926b40fdabb97a72a90c144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a unit from a pool with timed wait.  <a href="../../d9/d52/group__POOL.html#ga2352e41d6926b40fdabb97a72a90c144">More...</a><br /></td></tr>
<tr class="separator:ga2352e41d6926b40fdabb97a72a90c144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f37f5da3f8c2d8a0eb349063e31f3fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa">ABT_pool_push</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> unit)</td></tr>
<tr class="memdesc:ga8f37f5da3f8c2d8a0eb349063e31f3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a unit to a pool.  <a href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa">More...</a><br /></td></tr>
<tr class="separator:ga8f37f5da3f8c2d8a0eb349063e31f3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7747df606be0704dd7894ac79dd56b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga2d7747df606be0704dd7894ac79dd56b">ABT_pool_remove</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> unit)</td></tr>
<tr class="memdesc:ga2d7747df606be0704dd7894ac79dd56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specified work unit from a pool.  <a href="../../d9/d52/group__POOL.html#ga2d7747df606be0704dd7894ac79dd56b">More...</a><br /></td></tr>
<tr class="separator:ga2d7747df606be0704dd7894ac79dd56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1c11ccced444023a1fab17c148a5ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga4e1c11ccced444023a1fab17c148a5ca">ABT_pool_print_all</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void *arg, void(*print_fn)(void *, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>))</td></tr>
<tr class="memdesc:ga4e1c11ccced444023a1fab17c148a5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a print function to every work unit in a pool using a user-defined function.  <a href="../../d9/d52/group__POOL.html#ga4e1c11ccced444023a1fab17c148a5ca">More...</a><br /></td></tr>
<tr class="separator:ga4e1c11ccced444023a1fab17c148a5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4cb8502f813229d2fbb5e0961ffdf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3">ABT_pool_set_data</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void *<a class="el" href="../../df/dea/structdata.html">data</a>)</td></tr>
<tr class="memdesc:gaae4cb8502f813229d2fbb5e0961ffdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user data in a pool.  <a href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3">More...</a><br /></td></tr>
<tr class="separator:gaae4cb8502f813229d2fbb5e0961ffdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e9bbf2126b7c2b951068bafbd47fde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gac5e9bbf2126b7c2b951068bafbd47fde">ABT_pool_get_data</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, void **<a class="el" href="../../df/dea/structdata.html">data</a>)</td></tr>
<tr class="memdesc:gac5e9bbf2126b7c2b951068bafbd47fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve user data from a pool.  <a href="../../d9/d52/group__POOL.html#gac5e9bbf2126b7c2b951068bafbd47fde">More...</a><br /></td></tr>
<tr class="separator:gac5e9bbf2126b7c2b951068bafbd47fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398216ecd06e4ae64396c2565ecb4efa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#ga398216ecd06e4ae64396c2565ecb4efa">ABT_pool_add_sched</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, <a class="el" href="../../d0/d83/group__SCHED.html#gadf0a564b506bb4a288f49cbfd3116025">ABT_sched</a> sched)</td></tr>
<tr class="memdesc:ga398216ecd06e4ae64396c2565ecb4efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new work unit associated with a scheduler and push it to a pool.  <a href="../../d9/d52/group__POOL.html#ga398216ecd06e4ae64396c2565ecb4efa">More...</a><br /></td></tr>
<tr class="separator:ga398216ecd06e4ae64396c2565ecb4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b9d5f542cb31852aaa4d7079350e74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d52/group__POOL.html#gae3b9d5f542cb31852aaa4d7079350e74">ABT_pool_get_id</a> (<a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> pool, int *id)</td></tr>
<tr class="memdesc:gae3b9d5f542cb31852aaa4d7079350e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of a pool.  <a href="../../d9/d52/group__POOL.html#gae3b9d5f542cb31852aaa4d7079350e74">More...</a><br /></td></tr>
<tr class="separator:gae3b9d5f542cb31852aaa4d7079350e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group is for Pool. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6bbc8a95dbe08348262228f3355652b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bbc8a95dbe08348262228f3355652b2">&#9670;&nbsp;</a></span>ABT_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ABT_pool_opaque* <a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool handle type. </p>
<p>A NULL handle of this type is <code>ABT_POOL_NULL</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00838">838</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="gaf37f3c8382adf2e34fb1f02ae07d03c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf37f3c8382adf2e34fb1f02ae07d03c8">&#9670;&nbsp;</a></span>ABT_pool_access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool access type. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00855">855</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="ga4b2554363a286799e1e0f4be8b442802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b2554363a286799e1e0f4be8b442802">&#9670;&nbsp;</a></span>ABT_pool_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ABT_pool_config_opaque* <a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool configuration handle type. </p>
<p>A NULL handle of this type is <code>ABT_POOL_CONFIG_NULL</code>. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00845">845</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="ga3e2f99de4456f4816000b4d1589bee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e2f99de4456f4816000b4d1589bee6a">&#9670;&nbsp;</a></span>ABT_pool_kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a> <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined pool type. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00850">850</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad33f04702fb8618eed4f6ece04041ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33f04702fb8618eed4f6ece04041ecf">&#9670;&nbsp;</a></span>ABT_pool_access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool access type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad33f04702fb8618eed4f6ece04041ecfa6b52ca5bbffb03291d493257a8fe5bed"></a>ABT_POOL_ACCESS_PRIV&#160;</td><td class="fielddoc"><p>The created pool may be pushed and popped by only one execution stream in the lifetime of the pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad33f04702fb8618eed4f6ece04041ecfa9385bbd5d15bee55652e14e7546a0425"></a>ABT_POOL_ACCESS_SPSC&#160;</td><td class="fielddoc"><p>The created pool may be pushed by only one execution stream and popped by only one execution stream in the lifetime of the pool. The two execution streams can be different. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad33f04702fb8618eed4f6ece04041ecfabb04cf57d6a62299db2783422069d1ef"></a>ABT_POOL_ACCESS_MPSC&#160;</td><td class="fielddoc"><p>The created pool may be popped by only one execution stream in the lifetime of the pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad33f04702fb8618eed4f6ece04041ecfa2d9b6671e37097bb153513c200a2ad46"></a>ABT_POOL_ACCESS_SPMC&#160;</td><td class="fielddoc"><p>The created pool may be pushed by only one execution stream in the lifetime of the pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad33f04702fb8618eed4f6ece04041ecfaef5831d28ade4eb4b2a8e69a4c5bb39f"></a>ABT_POOL_ACCESS_MPMC&#160;</td><td class="fielddoc"><p>No restriction regarding a caller of pushing and popping operations. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00522">522</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<a id="ga3d9e73381c78389a50ef463732e672a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9e73381c78389a50ef463732e672a1">&#9670;&nbsp;</a></span>ABT_pool_kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predefined pool type. </p>
<p>Predefined pools provide all the pool functions that are defined in <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool.">ABT_pool_def</a></code> unless otherwise noted. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3d9e73381c78389a50ef463732e672a1a9f3f606b821abf78ccefd65ae5ce494c"></a>ABT_POOL_FIFO&#160;</td><td class="fielddoc"><p>FIFO pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3d9e73381c78389a50ef463732e672a1a0cb3dad152f9501d06400bd075c4dbd6"></a>ABT_POOL_FIFO_WAIT&#160;</td><td class="fielddoc"><p>FIFO pool with a waiting ability. If a caller's pop operation fails, either an execution stream running the caller or a calling external thread will suspend for a while. This can reduce CPU utilization when a pool is empty, but it increases an overhead of each pool operation.</p>
<p>If the user does not know how <code>ABT_POOL_FIFO_WAIT</code> works, <code>ABT_POOL_FIFO</code> is recommended. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d5/d7d/abt_8h_source.html#l00504">504</a> of file <a class="el" href="../../d5/d7d/abt_8h_source.html">abt.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga398216ecd06e4ae64396c2565ecb4efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga398216ecd06e4ae64396c2565ecb4efa">&#9670;&nbsp;</a></span>ABT_pool_add_sched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_add_sched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d83/group__SCHED.html#gadf0a564b506bb4a288f49cbfd3116025">ABT_sched</a>&#160;</td>
          <td class="paramname"><em>sched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new work unit associated with a scheduler and push it to a pool. </p>
<p><a class="el" href="../../d9/d52/group__POOL.html#ga398216ecd06e4ae64396c2565ecb4efa" title="Create a new work unit associated with a scheduler and push it to a pool.">ABT_pool_add_sched()</a> creates a work unit that works as a scheduler <code>sched</code> and pushes the newly created work unit to <code>pool</code>. See <code><a class="el" href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa" title="Push a unit to a pool.">ABT_pool_push()</a></code> for the push operation. The created work unit is automatically freed when it finishes its scheduling function.</p>
<p>While the created work unit is using <code>sched</code>, the user may not free <code>sched</code>. Associating <code>sched</code> with more than one work unit causes undefined behavior.</p>
<p><code>sched</code> should have been created by <code><a class="el" href="../../d0/d83/group__SCHED.html#gaf6e505eaab2fe977bbaddb5b19c6b413" title="Create a new scheduler with a scheduler definition.">ABT_sched_create()</a></code> or <code><a class="el" href="../../d0/d83/group__SCHED.html#gac3ea78b200ae62bf24deecf385a33f7b" title="Create a new scheduler with a predefined scheduler type.">ABT_sched_create_basic()</a></code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>ABT_ERR_INV_SCHED</code> is returned if this routine finds <code>sched</code> is already used.<br  />
 <b>[Argobots 2.0]</b> The results are undefined if <code>sched</code> is already used. <dl class="section user">
<dt>Rationale</dt>
<dd>The current implementation of this check is crude since whether a scheduler is used or not is not maintained atomically. From Argobots 2.0, it becomes the user's responsibility to guarantee that <code>sched</code> is not used. Note that Argobots 1.x does not perform this check atomically, so the user may not concurrently call any routines that attempt to use the same scheduler by assuming that only one of them would succeed. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_INV_SCHED</code> is returned if <code>sched</code> is <code>ABT_SCHED_NULL</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
<b>[Argobots 1.x]</b> <code>ABT_ERR_INV_SCHED</code> is returned if <code>sched</code> is being used.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
<b>[Argobots 2.0]</b> If <code>sched</code> is being used, the results are undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sched</td><td>scheduler handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00784">784</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga7a000646ad0b5899ee47779d051758e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a000646ad0b5899ee47779d051758e8">&#9670;&nbsp;</a></span>ABT_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dfc/structABT__pool__def.html">ABT_pool_def</a> *&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga4b2554363a286799e1e0f4be8b442802">ABT_pool_config</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>newpool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code> creates a new pool, given by the pool definition (<code>def</code>) and a pool configuration (<code>config</code>), and returns its handle through <code>newpool</code>. If <code>p_init</code> is not <code>NULL</code>, this routine calls <code>p_init()</code> with <code>newpool</code> as the first argument and <code>config</code> as the second argument. This routine returns an error returned by <code>p_init()</code> if <code>p_init()</code> does not return <code>ABT_SUCCESS</code>.</p>
<p>The user can pass <code>ABT_POOL_CONFIG_NULL</code> as <code>config</code>. The configuration is passed as the parameter of the initialization function of the pool.</p>
<p><code>def</code> must define all the non-optional functions. See <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool.">ABT_pool_def</a></code> for details.</p>
<p>The caller of each pool function is undefined, so a program that relies on the caller of pool functions is non-conforming.</p>
<dl class="section note"><dt>Note</dt><dd>Specifically, any explicit or implicit context-switching operation in a pool function may cause undefined behavior.</dd></dl>
<p>This routine copies <code>def</code> and <code>config</code>, so the user can free <code>def</code> and <code>config</code> after this routine returns.</p>
<p>The created pool is not automatically freed, so <code>newpool</code> must be freed by <code><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60" title="Free a pool.">ABT_pool_free()</a></code> after its use unless <code>newpool</code> is associated with the main scheduler of the primary execution stream.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="../../d4/d00/group__ENV.html#ga70dc165656888def26f8cb6c047a6289" title="Finalize the Argobots execution environment.">ABT_finalize()</a></code> frees the primary execution stream, its main scheduler, and pools associated with the main scheduler.</dd></dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>newpool</code> is set to <code>ABT_POOL_NULL</code> if an error occurs.<br  />
 <b>[Argobots 2.0]</b> <code>newpool</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>newpool</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
An error code returned by <code>p_init()</code> is returned if <code>p_init()</code> does not return <code>ABT_SUCCESS</code>.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>def</code> is <code>NULL</code>, the results are undefined.<br  />
If any non-optional pool function of <code>def</code> is <code>NULL</code>, the results are undefined.<br  />
If <code>newpool</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>pool definition required for pool creation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>pool configuration for pool creation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newpool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00072">72</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="gaae479c7d7ae2816d8a953ea307611b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae479c7d7ae2816d8a953ea307611b49">&#9670;&nbsp;</a></span>ABT_pool_create_basic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_create_basic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga3d9e73381c78389a50ef463732e672a1">ABT_pool_kind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d7d/abt_8h.html#a28854ddb62b26e4a2ee42132671bbef0">ABT_bool</a>&#160;</td>
          <td class="paramname"><em>automatic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>newpool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pool from a predefined type. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code> creates a new pool, given by the pool type <code>kind</code>, the access type <code>access</code>, and the automatic flag <code>automatic</code>, and returns its handle through <code>newpool</code>.</p>
<p><code>kind</code> specifies the implementation of <code>newpool</code>. See <code><a class="el" href="../../d9/d52/group__POOL.html#ga3e2f99de4456f4816000b4d1589bee6a" title="Predefined pool type.">ABT_pool_kind</a></code> for details of predefined pools.</p>
<p><code>access</code> hints at the usage of the created pool. Argobots may choose an optimized implementation for a pool with a more restricted access type (<code><a class="el" href="../../d9/d52/group__POOL.html#ggad33f04702fb8618eed4f6ece04041ecfa6b52ca5bbffb03291d493257a8fe5bed">ABT_POOL_ACCESS_PRIV</a></code> is the most strict access type). See <code><a class="el" href="../../d9/d52/group__POOL.html#gaf37f3c8382adf2e34fb1f02ae07d03c8" title="Pool access type.">ABT_pool_access</a></code> for details.</p>
<p>If <code>automatic</code> is <code>ABT_FALSE</code>, <code>newpool</code> is not automatically freed, so <code>newpool</code> must be freed by <code><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60" title="Free a pool.">ABT_pool_free()</a></code> after its use unless <code>newpool</code> is associated with the main scheduler of the primary execution stream.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="../../d4/d00/group__ENV.html#ga70dc165656888def26f8cb6c047a6289" title="Finalize the Argobots execution environment.">ABT_finalize()</a></code> frees the primary execution stream, its main scheduler, and pools associated with the main scheduler.</dd></dl>
<p>If <code>automatic</code> is <code>ABT_TRUE</code>, <code>newpool</code> is automatically freed when all the schedulers associated with <code>newpool</code> are freed. If the user does not associate <code>newpool</code> with a scheduler, the user needs to manually free <code>newpool</code> regardless of <code>automatic</code>.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> The Argobots runtime respects an access type of a pool and returns an error if possible if a pool access violation happens regarding an access type of a pool.<br  />
 <b>[Argobots 1.1]</b> The Argobots runtime does not check an access type of a pool. If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>This access type was used for access violation error check. This check will be removed in Argobots 1.1 since correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>newpool</code> is set to <code>ABT_POOL_NULL</code> if an error occurs.<br  />
 <b>[Argobots 2.0]</b> <code>newpool</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>newpool</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL_KIND</code> is returned if <code>kind</code> is not a valid pool kind.<br  />
<code>ABT_ERR_INV_POOL_ACCESS</code> is returned if <code>access</code> is not a valid pool access type.<br  />
<code>ABT_ERR_MEM</code> is returned if memory allocation fails.<br  />
 <code>ABT_ERR_SYS</code> is returned if an error related to system calls and standard libraries occurs.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If automatic is neither <code>ABT_TRUE</code> nor <code>ABT_FALSE</code>, the results are undefined.<br  />
If <code>newpool</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>type of the predefined pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">access</td><td>access type of the predefined pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">automatic</td><td><code>ABT_TRUE</code> if the pool should be automatically freed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newpool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00166">166</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga99295e7c312a3b0699b3f5c9ae4cfc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99295e7c312a3b0699b3f5c9ae4cfc60">&#9670;&nbsp;</a></span>ABT_pool_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga99295e7c312a3b0699b3f5c9ae4cfc60" title="Free a pool.">ABT_pool_free()</a></code> frees the resource used for the pool <code>pool</code> and sets <code>pool</code> to <code>ABT_POOL_NULL</code>. If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code> and <code>p_free</code> is not <code>NULL</code>, this routine calls <code>p_free()</code> with <code>pool</code> as the argument. The return value of <code>p_free()</code> is ignored. Afterward, this routine deallocates the resource used for <code>pool</code> and sets <code>pool</code> to <code>ABT_POOL_NULL</code>.</p>
<p><code>pool</code> must be empty and no work unit may be associated with <code>pool</code>.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> points to <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>pool</code> is <code>NULL</code>, the results are undefined.<br  />
If <code>pool</code> is not empty, the results are undefined.<br  />
 If any work unit is still associated with <code>pool</code>, the results are undefined.<br  />
If <code>pool</code> is accessed after calling this routine, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>pool handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00210">210</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga6089256f32498ee058e6df9478f95574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6089256f32498ee058e6df9478f95574">&#9670;&nbsp;</a></span>ABT_pool_get_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#gad33f04702fb8618eed4f6ece04041ecf">ABT_pool_access</a> *&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an access type of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga6089256f32498ee058e6df9478f95574" title="Get an access type of a pool.">ABT_pool_get_access()</a></code> returns the access type of the pool <code>pool</code> through <code>access</code>.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>access</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">access</td><td>access type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00244">244</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="gac5e9bbf2126b7c2b951068bafbd47fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5e9bbf2126b7c2b951068bafbd47fde">&#9670;&nbsp;</a></span>ABT_pool_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve user data from a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3" title="Set user data in a pool.">ABT_pool_set_data()</a></code> returns user data in the pool <code>pool</code> through <code>data</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The specific data of the newly created pool is <code>NULL</code>.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>data</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>user data in <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00732">732</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="gae3b9d5f542cb31852aaa4d7079350e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3b9d5f542cb31852aaa4d7079350e74">&#9670;&nbsp;</a></span>ABT_pool_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gae3b9d5f542cb31852aaa4d7079350e74" title="Get ID of a pool.">ABT_pool_get_id()</a></code> returns the ID of the pool <code>pool</code> through <code>id</code>.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>id</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>pool ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00834">834</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="gaafe8ef10c4d7fe1c7f7263fdc56fa58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafe8ef10c4d7fe1c7f7263fdc56fa58e">&#9670;&nbsp;</a></span>ABT_pool_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaafe8ef10c4d7fe1c7f7263fdc56fa58e" title="Get the size of a pool.">ABT_pool_get_size()</a></code> returns the size of the pool <code>pool</code> through <code>size</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to a value returned by <code>p_get_size()</code> called with <code>pool</code> as its argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to the number of work units in <code>pool</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>size</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>size of <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00333">333</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga89312324e2c5a199992323035d9bb7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89312324e2c5a199992323035d9bb7c2">&#9670;&nbsp;</a></span>ABT_pool_get_total_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_get_total_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga89312324e2c5a199992323035d9bb7c2" title="Get the total size of a pool.">ABT_pool_get_total_size()</a></code> returns the total size of the pool <code>pool</code> through <code>size</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to the sum of a value returned by <code>p_get_size()</code> called with <code>pool</code> as its argument and the number of blocking work units that are associated with <code>pool</code>.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine sets <code>size</code> to the sum of the number of work units including in <code>pool</code> and the number of blocking work units associated with <code>pool</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. <dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>size</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>total size of <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00290">290</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga50138fd611a69d657d3314cd606c68f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50138fd611a69d657d3314cd606c68f6">&#9670;&nbsp;</a></span>ABT_pool_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *&#160;</td>
          <td class="paramname"><em>p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a work unit from a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6" title="Pop a work unit from a pool.">ABT_pool_pop()</a></code> pops a work unit from the pool <code>pool</code> and sets it to <code>p_unit</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>p_unit</code> to a value returned by <code>p_pop()</code> called with <code>pool</code> as its argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine tries to pop a work unit from <code>pool</code>. If this routine successfully pops a work unit, this routine sets <code>p_unit</code> to the obtained handle of <code>ABT_unit</code>. Otherwise, this routine sets <code>ABT_UNIT_NULL</code> to <code>p_unit</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p><dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> If an external thread calls this routine, <code>ABT_ERR_INV_XSTREAM</code> is returned.<br  />
 <b>[Argobots 1.1]</b> An external thread may call this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 narrows the type of the caller without any reason. Argobots 1.1 fixes it. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>p_unit</code> is set to <code>ABT_UNIT_NULL</code> if an error occurs.<br  />
 <b>[Argobots 2.0]</b> <code>p_unit</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>p_unit</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd><b>[Argobots 1.x]</b> This routine can be called in a ULT context and a tasklet context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.<br  />
<b>[Argobots 2.0]</b> This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>p_unit</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_unit</td><td>unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00387">387</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga2352e41d6926b40fdabb97a72a90c144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2352e41d6926b40fdabb97a72a90c144">&#9670;&nbsp;</a></span>ABT_pool_pop_timedwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_pop_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *&#160;</td>
          <td class="paramname"><em>p_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstime_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a unit from a pool with timed wait. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga2352e41d6926b40fdabb97a72a90c144" title="Pop a unit from a pool with timed wait.">ABT_pool_pop_timedwait()</a></code> pops a work unit from the pool <code>pool</code> and sets it to <code>p_unit</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>p_unit</code> to a value returned by <code>p_pop_timedwait()</code> called with <code>pool</code> as its first argument and <code>abstime_sec</code> as the second argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine tries to pop a work unit from <code>pool</code>. If <code>pool</code> is empty, an underlying execution stream or an external thread that calls this routine is blocked on <code>pool</code> until the current time exceeds <code>abstime_secs</code>. If this routine successfully pops a work unit, this routine sets <code>p_unit</code> to the obtained handle of <code>ABT_unit</code>. Otherwise, this routine sets <code>ABT_UNIT_NULL</code> to <code>p_unit</code>.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>abstime_secs</code> can be calculated by adding an offset time to a value returned by <code><a class="el" href="../../d0/dde/group__TIMER.html#ga872b14356c27d22d4f18c85303a37608" title="Get elapsed wall clock time.">ABT_get_wtime()</a></code>.</dd></dl>
<p>This routine is deprecated. The user should use <code><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302" title="Pop a unit from a pool with wait.">ABT_pool_pop_wait()</a></code> instead.</p>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p><dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> If an external thread calls this routine, <code>ABT_ERR_INV_XSTREAM</code> is returned.<br  />
 <b>[Argobots 1.1]</b> An external thread may call this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 narrows the type of the caller without any reason. Argobots 1.1 fixes it. </dd>
</dl>
</dd>
</dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><b>[Argobots 1.x]</b> <code>p_unit</code> is set to <code>ABT_UNIT_NULL</code> if an error occurs.<br  />
 <b>[Argobots 2.0]</b> <code>p_unit</code> is not updated if an error occurs. <dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>p_unit</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_POOL</code> is returned if <code>pool</code> does not support <code>p_pop_timedwait()</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>p_unit</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_unit</td><td>unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abstime_secs</td><td>absolute time for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00511">511</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="gaf22802d586052a8562abc07f779b5302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22802d586052a8562abc07f779b5302">&#9670;&nbsp;</a></span>ABT_pool_pop_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_pop_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a> *&#160;</td>
          <td class="paramname"><em>p_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a unit from a pool with wait. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302" title="Pop a unit from a pool with wait.">ABT_pool_pop_wait()</a></code> pops a work unit from the pool <code>pool</code> and sets it to <code>p_unit</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine sets <code>p_unit</code> to a value returned by <code>p_pop_wait()</code> called with <code>pool</code> as its first argument and <code>time_sec</code> as the second argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine tries to pop a work unit from <code>pool</code>. If <code>pool</code> is empty, an underlying execution stream or an external thread that calls this routine is blocked on <code>pool</code> for <code>time_sec</code> seconds. If this routine successfully pops a work unit, this routine sets <code>p_unit</code> to the obtained handle of <code>ABT_unit</code>. Otherwise, this routine sets <code>p_unit</code> to <code>ABT_UNIT_NULL</code>.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In most cases, <code><a class="el" href="../../d9/d52/group__POOL.html#ga50138fd611a69d657d3314cd606c68f6" title="Pop a work unit from a pool.">ABT_pool_pop()</a></code> is more efficient. <code><a class="el" href="../../d9/d52/group__POOL.html#gaf22802d586052a8562abc07f779b5302" title="Pop a unit from a pool with wait.">ABT_pool_pop_wait()</a></code> would be useful in cases where the user wants to make execution streams sleep when <code>pool</code> is empty.</dd></dl>
<dl class="section note">
<dt>Changes from Argobots 1.x to Argobots 2.0 (planned)</dt>
<dd><p class="startdd"><b>[Argobots 1.x]</b> <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool.">ABT_pool_def</a></code> does not define <code>p_pop_wait</code>. <br  />
 <b>[Argobots 2.0]</b> <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool.">ABT_pool_def</a></code> defines <code>p_pop_wait</code>. </p><dl class="section user">
<dt>Rationale</dt>
<dd>To maintain the ABI compatibility, <code>p_pop_wait</code> is excluded from <code><a class="el" href="../../d4/dfc/structABT__pool__def.html" title="A struct that defines a pool.">ABT_pool_def</a></code>. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.x]</b> <code>p_unit</code> is set to <code>ABT_UNIT_NULL</code> if an error occurs.<br  />
 <b>[Argobots 2.0]</b> <code>p_unit</code> is not updated if an error occurs. </p><dl class="section user">
<dt>Rationale</dt>
<dd>To ensure the atomicity of the API, Argobots 2.0 guarantees that the routine has no effect when an error is returned unless otherwise noted. Argobots 2.0 does not update <code>p_unit</code> when an error occurs. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_POOL</code> is returned if <code>pool</code> does not support <code>p_pop_wait()</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>p_unit</code> is <code>NULL</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_unit</td><td>unit handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_secs</td><td>duration of waiting time (seconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00445">445</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga4e1c11ccced444023a1fab17c148a5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1c11ccced444023a1fab17c148a5ca">&#9670;&nbsp;</a></span>ABT_pool_print_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_print_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, <a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>)&#160;</td>
          <td class="paramname"><em>print_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a print function to every work unit in a pool using a user-defined function. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga4e1c11ccced444023a1fab17c148a5ca" title="Apply a print function to every work unit in a pool using a user-defined function.">ABT_pool_print_all()</a></code> calls <code>print_fn()</code> for every work unit in the pool <code>pool</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine calls <code>p_pop_print()</code> with <code>pool</code> as its first argument, <code>arg</code> as the second argument, and <code>print_fn</code> as the third argument The return value of <code>p_pop_print()</code> is ignored.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine calls <code>print_fn()</code> for every work unit in <code>pool</code>. <code>print_fn()</code> is called with <code>arg</code> as its first argument and the handle of the work unit as the second argument.</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>As the name of the argument implies, <code>print_fn()</code> may not have any side effect; <code><a class="el" href="../../d9/d52/group__POOL.html#ga4e1c11ccced444023a1fab17c148a5ca" title="Apply a print function to every work unit in a pool using a user-defined function.">ABT_pool_print_all()</a></code> is for debugging and profiling. For example, changing the state of <code>ABT_unit</code> in <code>print_fn()</code> is forbidden.</dd></dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_POOL</code> is returned if <code>pool</code> does not support <code>p_print_all()</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>print_fn</code> is <code>NULL</code>, the results are undefined.<br  />
If the internal state of the Argobots is changed in <code>print_fn()</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument passed to <code>print_fn</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print_fn</td><td>user-defined print function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00666">666</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga8f37f5da3f8c2d8a0eb349063e31f3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f37f5da3f8c2d8a0eb349063e31f3fa">&#9670;&nbsp;</a></span>ABT_pool_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a unit to a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga8f37f5da3f8c2d8a0eb349063e31f3fa" title="Push a unit to a pool.">ABT_pool_push()</a></code> pushes a work unit <code>unit</code> to the pool <code>pool</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine calls <code>p_push()</code> with <code>pool</code> as its first argument and <code>unit</code> as the second argument.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine pushes a work unit <code>unit</code> to <code>pool</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p><dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> <code>ABT_ERR_UNIT</code> is returned if <code>unit</code> is <code>ABT_UNIT_NULL</code>.<br  />
 <b>[Argobots 1.1]</b> <code>ABT_ERR_INV_UNIT</code> is returned if <code>unit</code> is <code>ABT_UNIT_NULL</code>. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 returned an error code which is obviously wrong. Argobots 1.1 fixes the error code for consistent behavior with other Argobots routines. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_INV_UNIT</code> is returned if <code>unit</code> is <code>ABT_UNIT_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>unit</code> is not associated with <code>pool</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit</td><td>unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00560">560</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="ga2d7747df606be0704dd7894ac79dd56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d7747df606be0704dd7894ac79dd56b">&#9670;&nbsp;</a></span>ABT_pool_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dab/group__UNIT.html#ga2766d98ace73a538d42ff64a8b999baf">ABT_unit</a>&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a specified work unit from a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#ga2d7747df606be0704dd7894ac79dd56b" title="Remove a specified work unit from a pool.">ABT_pool_remove()</a></code> removes a work unit <code>unit</code> from the pool <code>pool</code>.</p>
<ul>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#ga7a000646ad0b5899ee47779d051758e8" title="Create a new pool.">ABT_pool_create()</a></code>:</p>
<p class="startli">This routine calls <code>p_remove()</code> with <code>pool</code> as its first argument and <code>unit</code> as the second argument. The return value of <code>p_remove()</code> is ignored.</p>
</li>
<li><p class="startli">If <code>pool</code> is created by <code><a class="el" href="../../d9/d52/group__POOL.html#gaae479c7d7ae2816d8a953ea307611b49" title="Create a new pool from a predefined type.">ABT_pool_create_basic()</a></code>:</p>
<p class="startli">This routine removes a work unit <code>unit</code> from the pool <code>pool</code> and returns <code>ABT_SUCCESS</code>.</p>
</li>
</ul>
<dl class="section attention">
<dt>Changes from Argobots 1.0 to Argobots 1.1</dt>
<dd><p class="startdd"><b>[Argobots 1.0]</b> If a pool access violation happens regarding an access type of a pool, an error is returned.<br  />
 <b>[Argobots 1.1]</b> If a pool access violation happens regarding an access type of a pool, the results are undefined. </p><dl class="section user">
<dt>Rationale</dt>
<dd>The implementation of Argobots 1.0 does not strictly check this error, so some user programs work without any problem if it is no simultaneously accessed, although it is a user error. Such an error is often not recoverable, for example, when an execution stream pushes a ULT to a pool that cannot be accessed by this execution stream. Correctly implementing the access violation check could break the actual API compatibility. From Argobots 1.1, it is the user's responsibility to manage access to pools. </dd>
</dl>
<p class="enddd"><b>[Argobots 1.0]</b> If an external thread calls this routine, <code>ABT_ERR_INV_XSTREAM</code> is returned.<br  />
 <b>[Argobots 1.1]</b> An external thread may call this routine. </p><dl class="section user">
<dt>Rationale</dt>
<dd>Argobots 1.0 narrows the type of the caller without any reason. Argobots 1.1 fixes it. </dd>
</dl>
</dd>
</dl>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
<code>ABT_ERR_INV_UNIT</code> is returned if <code>unit</code> is <code>ABT_UNIT_NULL</code>.<br  />
<code>ABT_ERR_POOL</code> is returned if <code>pool</code> does not support <code>p_remove()</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>unit</code> is not in <code>pool</code>, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit</td><td>unit handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00612">612</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
<a id="gaae4cb8502f813229d2fbb5e0961ffdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae4cb8502f813229d2fbb5e0961ffdf3">&#9670;&nbsp;</a></span>ABT_pool_set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ABT_pool_set_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d52/group__POOL.html#ga6bbc8a95dbe08348262228f3355652b2">ABT_pool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set user data in a pool. </p>
<p><code><a class="el" href="../../d9/d52/group__POOL.html#gaae4cb8502f813229d2fbb5e0961ffdf3" title="Set user data in a pool.">ABT_pool_set_data()</a></code> sets user data of the pool <code>pool</code> to <code>data</code>. The old value is overwritten.</p>
<dl class="section user"><dt>Execution context</dt><dd>This routine can be called in any execution context. Argobots must be initialized. This routine does not switch the context of the calling ULT unless any user-defined function that is involved in this routine switch the context of the calling ULT.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd><code>ABT_SUCCESS</code> is returned if this routine succeeds.<br  />
<code>ABT_ERR_INV_POOL</code> is returned if <code>pool</code> is <code>ABT_POOL_NULL</code>.<br  />
 </dd></dl>
<dl class="section user"><dt>Undefined behavior</dt><dd>If Argobots is not initialized, the results are undefined.<br  />
If <code>pool</code> is accessed concurrently, the results are undefined.<br  />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>pool handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>user data in <code>pool</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/de5/pool_8c_source.html#l00699">699</a> of file <a class="el" href="../../d4/de5/pool_8c_source.html">pool.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 10 2021 03:10:08 for ARGOBOTS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
